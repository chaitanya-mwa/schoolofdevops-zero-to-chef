{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Chef Tutorial by School of Devops This is a Lab Guide which goes along with the Zero to Docker Course by School of Devops. For information about the devops trainign courses visit schoolofdevops.com . Team Gourav Shah Meenachisundaram V","title":"Home"},{"location":"#welcome-to-chef-tutorial-by-school-of-devops","text":"This is a Lab Guide which goes along with the Zero to Docker Course by School of Devops. For information about the devops trainign courses visit schoolofdevops.com .","title":"Welcome to Chef Tutorial by School of Devops"},{"location":"#team","text":"Gourav Shah Meenachisundaram V","title":"Team"},{"location":"01_introduction/","text":"How I got started with Puppet, Chef and Devops ? As Georg Buchner said: We are only puppets, our strings are being pulled by unknown forces. My journey with Devops began with Puppet ( a tool similar to chef, in fact Chef has from this) back in 2008, when as I was part of the Ops Team managing web scale infrastructure for a SaaS company. Our team consisted of ops engineers in India and US working out of their respective timezones, keeping lights on 24x7. As part of day to day operations, all of us would make ad hoc changes to the servers, and not always communicate back with the team on the other side of the globe. We did not have daily sync up meetings either. As a result of this ad hoc, inconsistent setup, regularly, issues would pop up with the product, in pre production/integration as well as in production environments. Being in charge of triaging, my team would spend a lot of time flipping through logs, doing root cause analysis and figuring out whether its a problem due to inconsistent configurations or a actual code related issue. Tired of this fire fighting, we started looking for solutions to help us efficiently manage this environment. And thats when we came across Puppet, which was popular, was already picked by likes of google, and had an active community around it. We started using it to setup the infrastructure as well as manage changes through a centralized console. Results were immediate, and tangible. After implementing puppet based configuration management system, We now had a centralized tool which streamlined our process of managing configurations. This resulted in minimal ad hoc changes and consistency across the environments. Visibility was another important outcome. Since we started writing infrastructure as a Code, everyone including the developers had visibility into the way infrastructure was configured. All one had to do was look at the svn/git repository, the last commits to know what changes were made, my whom and when. What more, developers could even tweak the application properties in their own integration environments. Error rates , specially related to configurations dropped significantly, giving us more time back in our day, to focus on scale and other important issues. That was the beginning of my journey with devops automation tools. Even though Puppet was the first kid on the block, Chef, which was released in 2009 has evolved to be a very mature, powerful and flexible automation tool, with a great community built around it. Before we start looking into what makes puppet a excellent choice for a automation tool, lets first understand what configuration management is about. Infrastructure Life Events and Chef If you are the one who is in the business of managing more than a handful of systems, you should be familiar with the term \"Configuration Management\" (not to confuse with traditional Software Configuration Management or SCM). Be it physical servers, virtual machines or cloud based setup, infrastructure typically goes through the following life events, Provisioning Provision servers - physical, virtual or cloud. This is where the servers are brought into being. Install Operating System either using manual/automated install process or using an image/template. Configuration Management Base Systems Configurations: Prepare the systems with the base configurations such as users, packages, security configurations, network setup etc. Tech Stack: install and configure services such as apache, tomcat, middle wares, setup cron jobs, install and configure databases etc. Application: Deploy the application code on top of the tech stack configured. This is where the code written by your team gets deployed with relevant configurations. Change Management Configurations made during the initial setup do not remain do not last for a life time. Infrastructure is in the constant state of flux and evolves over time. Change management involves, Updating configurations parameters across a class of servers eg. update port that web server is running on. Deploying new versions of the application code, push security patches etc, install additional services. Chef serves as a excellent tool for Configuration Management as well as Change Management. And along with tools such as AWS Opsworks, Cloud Plugins, Vagrant, Terraform it could also automate provisioning of servers too. However chef as a tool by itself does have an ability to provision and comes in to play once the Operating System is installed and chef agent is setup. If you are looking for a tool which could also provision servers, and do it effectively, you should consider Ansible. Evolution of Configuration Management The need for managing configurations and ongoing changes had been a challenge which has seen various approaches. Lets have a look at the evolution of configuration management, Manual As systems engineers, we almost always begin configuring systems by hand, in a ad hoc manner. This approach is the easiest, and useful when you have only a handful of systems to manage, simple configurations, and where you do not have repeatable tasks or updates. However, as you start growing, this crude approach quickly gets out of control. It also involves manual processes, which mandates a operator to be present, and is prone to errors or omissions. Scripts Scripts allow one to take a sequence of commands to run and put it in a procedural program. Whenever there is need to repeat the process, scripts come in very handy. Some of the popular scripting languages amongst the systems personnel include shell/bash, perl, python, ruby or powershell. Scripts are almost always the first approach towards automating manual tasks. However, scripts are not scalable or flexible enough to manage a sophisticated infrastructure spanning across multitude of environments or the ones involving multiple different operating systems etc. Configuration Management and Software Configuration Management Software Configuration Management is referred to often with context of Revision Control which is about tracking changes to the application code. This is just one part of a larger field of Configuration Management. Golden Images/ Templates Golden images, or templates, or simply os images, are probably the quickest way to deploy servers complete with configurations, specially in virtual or cloud environments. Images are nothing but pre baked templates with operations system files, applications, and configurations. Take any cloud provider, and one of the first components to choose while you provision a server is the images. A lot of organizations these days package their products in the form of images such as ova, vmdk or even vagrant's box format. However images have one major problem i.e. change management. Every time there is an update, even a single line change, one needs to build a new image. Not only this complete system image needs to be distributed but also existing systems need to be replaced with the new image. Imagine doing that in a dynamic environment involving frequent updates across hundreds of servers. That could get too cumbersome. And thats where the need to come up with a new approach. Infrastructure as a Code \"Infrastructure as a Code\" or \"Programmable Infrastructure\" is where today's generation tools such as Puppet, Chef, Ansible, Salt fit in. These tools essentially allow one to write the state of the infrastructure using a higher level descriptive language and store it as a code. Since this is a code, one could bring in the best practices that developers have been following for years e.g. using revision control systems, use of sophisticated editors, test driven development, peer programming etc. You could even build the complete infrastructure from scratch in case of a disaster, as long as you have the code repository, compute resources and data backups in place. Since this code is written in a simple declarative syntax, it is self documenting and offers visibility to all stakeholders into the way infrastructure is built and configured. Approach Advantages Disadvantages Manual \\pbox{5cm}{simple} \\pbox{5cm}{ad hoc, error prone, inconsistent, not repeatable} Scripts \\pbox{5cm}{repeatable, automated} \\pbox{5cm}{procedural, not scalable, inflexible} Images \\pbox{5cm}{repeatable, automated} \\pbox{5cm}{size, change management is not easy} Infrastructure as a Code \\pbox{5cm}{repeatable, flexible, scalable, automated, consistent} \\pbox{5cm}{agent based, learning curve} Why to use chef ? Now that we have started discussion on Infrastructure as a Code, specifically chef, lets discuss about the specific features of chef that make it a useful tool for configuration and change management. Declarative vs Procedural Approach Scripts take a procedural approach towards automation. With scripts, we focus on the how part. e.g. how to install a package, how to create a user, how to modify it later, how to do it on a specific platform. And if you would want to add a support for another platform, you may have to add additional procedure and write a conditional to check for the platform and call the relevant code. This involves a lot of efforts. On the other hand, chef takes a declarative approach towards automation. With chef, our focus changes from how part to what . Instead of writing procedures, we start using a simple declarative syntax to define the desired state of infrastructure. Let me explain this with an analogy. Lets say we want to build a house. When we set out to do so, we hire a contractor, who in turns has a team of construction workers who know how to build it brick by brick. They do all the hard work to bring our house into a reality. Thats the how part. On the other hand, you have a Architect. Lets take a moment and think about what he or she does. An Architect creates a plan, a blue print, which is nothing but a description of how your house should look like. The architect envisions the end state of your house, thinks about what should it consists of, breaks it down into components, and starts creating specification for each. He would then stitch it together to create a blueprint of our house, and hands it to the contractor to go and build it. This is the how part. Thats exactly what we would start doing with chef, only difference being, we write the specification for desired state of IT infrastructure. Resource Abstraction Layer We just learnt about chef allowing us to write the desired state of the infrastructure using a descriptive language. Now this concept is brought into a reality with the its Domain Specific Language(DSL) which consists of a Resource Abstraction Layer (RAL). Lets describe how this works, TODO : Create an image for each step below. chef looks at infrastructure as a collection of entities to manage e.g. package, service, user, network interface etc. It then takes the procedures, the actual logic to manage these entities and bundles it into something called as Providers . Providers are platform specific. That way, each entity may have multiple providers e.g. managing user on linux vs osx vs windows. On top of these procedures, chef creates an abstraction layer. Instead of defining the procedures, it offers the users a simple declarative syntax to define the state of the entity and its properties, in the form of Resources . chef, then does the translation between Resources and Providers, and calls the procedure to put the entity in to the desired state just as described by the user. This behavior allows the users of the chef to create policies stating what which entities should be present or absent, with what properties. Convergence and Idempotence chef reads the resources, calls the relevant providers for the platform it runs on, and ensures the desired state of the resource is achieved. While it does so, it may need to make changes to the system. But what if the resource has already achieved the desired state and needs no further updates? chef has the built in intelligence to know what is the current state of the resource is. Instead of making changes blindly, it first compares the current state of the resource with the desired state, and the makes a decision whether it requires any changes, and if yes, what changes to make. This process is called as convergence. TODO : Draw diagrams, maybe just a flowchart e.g. Lets assume we have written a resource to create a user with a password. user 'xyz' do uid '501' gid '501' home '/home/xyz' password '$1$foYKL0zO$elXbUOb/JjHqS4aI8O25i.' end First time chef applies this resource on the system, the user may not exist. chef detects the current state, compares it with the desired state which mentions it should exist, and finds the configuration drift. It then creates the user with the password to bring the current state to desired state. Lets assume we run chef again to apply the same resource. This time too it will compare the desired state with current state. Since the user is already present with the password provided, it deems no changes necessary. Instead of attempting to create the user again, it will skip the resource and move on to the next one. Lets assume we updated the password information for the user in our code description of the resource, and excute chef. This time, while comparing the current state with desired state, it detects that the user is present, but the password is updated. It does not attempt to create a user, but only changes one property i.e. password. Idempotence is a useful property to ensures that chef maintains the state of the infrastructure such that its always in the policy. This also makes change management easier as one could keep running chef as a service which invokes itself at regular intervals, pulls the changes, and apply only what is changed. Centralized Configuration Management System A typical installation of chef involves a chef Master, which is a centralized management console and Agents runnings on every node managed. Any changes to nodes have to go through the chef Master. This streamlines the process of pushing updated. Instead of iterating over a list of hosts using a for loop or other such methods, or logging into each system to make changes, all you need to do is push updates to chef Server, from where those are automatically propogated to the nodes. TODO Pull Approach While chef offers a centralized management approach, it works unlike most client server schemes. Instead of pushing updates to the nodes from master, its the duty of chef agent to go the master, pull changes, and apply. Pull method offers more flexibility and scalability for the following reasons, Each node could decide how frequently or infrequently it should update. Some systems need frequent updates, where as others need not be updated for weeks. This could be controlled at per client level. No need to manage inventory and connection details on the master. Nodes could come and go, and could be configured based on dynamic rules to classify them based on certain property e.g. host names, environments, or even hardware addresses. With push based approach, master must have a ability reach out and connect to each node managed in order to configure it. A lot of times you may have a master on a cloud or in a separate data center than nodes being managed, which could be behind a firewall or NAT device in a private network. In case of pull method, as long as the master is available on a well known address, and is reachable from the nodes, configurations can be pulled and applied. Code vs Data A lot of applications that we configure on our servers are generic eg. apache, tomcat, mysql, mongo. These applications have a install base of hundreds of thousands of servers, used by organizations across the globe. Ever wondered how these become specific to your environment ? Even though you use the same apache web server used by many others, its how you configure it makes the difference. Even in single organization, you may have a apache server which behaves differently in different environment based on the configuration profile created. The process of setting up an application involves, Installing the generic application either from a source, package or a repository. Adding data. This where you set configuration parameters e.g. port, user, max connections, webroot for apache. Start, enable the service. chef allows separation of code and data. Using chef's DSL, we write infrastructure code to install packages start services etc. Code is generic. chef's attributes templates, along with dat bags and attribute precedence rules provide a way to create different configuration profiles specific to different nodes, environments, platforms etc. Shared Library of Infrastructure Code With chef's ability to separate code and configuration data, the declarative code that you write in the form of modules with chef becomes generic enough to be shared and be reused. And since this code is in the version control, hosted services such as github offer the perfect means to publish this code. As you start writing code with chef, you would discover about chef forge, a library of community written modules. At the time of writing, there are more than 4000 modules available on chef forge. Similar to a lot of open source code, you need not re invent the wheel. For most open source applications, you would find very sophisticated modules which you could use without even single line change. Download the modules, install it on your own chef master, add configuration profile, and off you go. Cloud Integrations With emergence of cloud, computing is moving towards the utility model. More and more organizations have already migrated or contemplating to migrate a partial or whole of their computing setup to cloud. And with that happening, which ever automation tool that you would consider, needs to have a close integration with the cloud platform that you plan to use. Provisioning of infrastructure components before chef comes in and starts configuring There are two ways chef provides a way for this, Through library of custom resources/libraries which allow one to write provisioning of cloud components in the form of resources. Cloud specific tools e.g. Cloudformation on AWS or Heat on Openstack are some of the tools which help provision components which are specific to that cloud and then call chef to do the configurations. Third party tools such as Vagrant, Terraform have in turn ability to talk to multiple cloud providers. These tools typically provision servers on the cloud and then hand it off to chef for configurations. Iterative Approach to Automation However convinced you are with chef, scrapping your existing automation tool overnight for a shiny new tool may have unknown risks attached. More over, it may could be challenging to get a buy in from your management to invest in time, money and resources to implement a new solution without showing them the value. With chef, you could take a iterative approach towards automation. You could start with a single application, or even a single entity such as a system user to manage. Once you see the value, show it to all stake holders, get a buy in and move to the next application, one at a time. Device Support Managing configurations on systems running common operating systems such as windows, linux, os x, where chef agent application can be installed is easy. Its a completely different beast when it comes to managing configurations on devices running their own specialized version of operating systems/firmwares. Examples are configuring CISCO's network switches routers, EMC's storage array. Along with programmable infrastructures, new concepts such as Software Defined Networking(SDN) and Software Defined Storage(SDS) are taking root and changing the way devices are being managed. chef supports managing devices in two ways, Devices that are based on linux and have chef agent ported to run on those can be configured the same way as other generic systems. Sub set of devices that do not have chef agent can still be configured with chef's device support over ssh/telnet. For such devices, chef uses push instead of pull approach. Audit and Compliance With ability to define the state of the infrastructure components as a code and then converge, one could easily codify the infrastructure policies and have them enforced. chefs ability to test, log changes, and reporting mechanisms help keeping a trail of the state of the systems and its components over time and track who made changes, when, if there are any nodes which have fallen out of policy etc. When to Use chef ? You should consider using chef for the following purposes, Configuration Management + Change Management: You have many nodes to deploy with changes happening often. You need to update the nodes and applications running on those often. Compliance and Audit : When your organization has to comply to policies and you need an ability to convert those policies into a code which would auto correct and bring the nodes into the policy in case of configuration drifts. You also need to audit the systems regularly and prepare reports to find out which nodes have drifted away from the policy etc. as well as mitigate such issues. Software Delivery : If you are in business of building software and delivering as ova images or similar, chef is better approach to deliver the product and push updates to it. Who is it for? Systems Administrators/Engineers who are managing systems at scale and need to install, configure, patch, monitor and maintain systems and prepared reports for. Application Operations Engineers who are responsible for installing, configuring, integrating, monitoring, maintaining application infrastructures. Build and release engineers who are in charge of setting up environments for CI/CD cycles, as well as deploy/release applications to production environments. Network Engineers who configure and maintain networking devices such as CISCO Routers and Switches at scale. Storage Administrators who configure and maintain storage devices. Developers who are building application delivery to their customers. Also as users of the develops tools, developers may need to change application properties for the environments that they create/use. What chef is not? Graphical Management Tool (e.g. SCCM): If you are looking for a tool which would allow you to manage everything through a graphical interface without writing any code or without ever having to use an editor, well chef is not the tool for you. I have come across many engineers, who say \"well, the capabilities of chef sounds great, but can I do all of this using a GUI where I can just click click and get things done.... ? \" Well, its infrastructure as a code is what we are talking about. Even though enterprise chef chef offers a nice GUI, its mostly for reporting and classifications. Since I started using chef and similar tools, I have been using text editors more often. Automated Testing Tool ( e.g. selenium ): Its not a silver bullet. Its not one solutions to all. I meet a lot of QA folks who have heard that chef would automate everything and you could use it for testing too. Well, there is always a special purpose tool for each task and the application testing is not chef's ball game. Sure chef could help in testing by letting you automate the process of building and configuring a fresh environment to run your tests inside, and give you ability to do it repeatedly. It also gives you a way to test infrastrcuture code. However, its not a test automation tool. Pure Application Deployment and Orchestration Tool: Even though chef has been talking about application orchestration, if you are looking for a tool purely for application deployments, rolling updates, canary releases, orchestrated deployments over multiple hosts, you have tools which do it better. A few tools I could suggest you for application deployment and orchestration are Asible, Capistrano, Code Deploy which are push based, and work better in such scenarios. Agent less Management System: Except for a sub set of network devices, chef mandates running agents on each node being managed. In fact its designed to be heavy on the agent side which is responsible to initiate communication with the master, pull policies, enforce and report back. If you need a agent less management system, chef is not the one. Again, I would suggest using Ansible in such cases, which works over ssh and is agent less. Software Configuration Management(SCM) Tool SCM is a part of the larger Configuration Management and typically refers to the practice of revision/version control. chef is not the tool which does the version control, however it can be used to replicate and manage software configurations across a cluster of nodes. A one stop Devops solutions chef Use Cases/ Customer Stories Chef vs Puppet chef vs Ansible chef vs Docker","title":"Introduction to Chef"},{"location":"01_introduction/#how-i-got-started-with-puppet-chef-and-devops","text":"As Georg Buchner said: We are only puppets, our strings are being pulled by unknown forces. My journey with Devops began with Puppet ( a tool similar to chef, in fact Chef has from this) back in 2008, when as I was part of the Ops Team managing web scale infrastructure for a SaaS company. Our team consisted of ops engineers in India and US working out of their respective timezones, keeping lights on 24x7. As part of day to day operations, all of us would make ad hoc changes to the servers, and not always communicate back with the team on the other side of the globe. We did not have daily sync up meetings either. As a result of this ad hoc, inconsistent setup, regularly, issues would pop up with the product, in pre production/integration as well as in production environments. Being in charge of triaging, my team would spend a lot of time flipping through logs, doing root cause analysis and figuring out whether its a problem due to inconsistent configurations or a actual code related issue. Tired of this fire fighting, we started looking for solutions to help us efficiently manage this environment. And thats when we came across Puppet, which was popular, was already picked by likes of google, and had an active community around it. We started using it to setup the infrastructure as well as manage changes through a centralized console. Results were immediate, and tangible. After implementing puppet based configuration management system, We now had a centralized tool which streamlined our process of managing configurations. This resulted in minimal ad hoc changes and consistency across the environments. Visibility was another important outcome. Since we started writing infrastructure as a Code, everyone including the developers had visibility into the way infrastructure was configured. All one had to do was look at the svn/git repository, the last commits to know what changes were made, my whom and when. What more, developers could even tweak the application properties in their own integration environments. Error rates , specially related to configurations dropped significantly, giving us more time back in our day, to focus on scale and other important issues. That was the beginning of my journey with devops automation tools. Even though Puppet was the first kid on the block, Chef, which was released in 2009 has evolved to be a very mature, powerful and flexible automation tool, with a great community built around it. Before we start looking into what makes puppet a excellent choice for a automation tool, lets first understand what configuration management is about.","title":"How I got started with Puppet, Chef  and Devops ?"},{"location":"01_introduction/#infrastructure-life-events-and-chef","text":"If you are the one who is in the business of managing more than a handful of systems, you should be familiar with the term \"Configuration Management\" (not to confuse with traditional Software Configuration Management or SCM). Be it physical servers, virtual machines or cloud based setup, infrastructure typically goes through the following life events, Provisioning Provision servers - physical, virtual or cloud. This is where the servers are brought into being. Install Operating System either using manual/automated install process or using an image/template. Configuration Management Base Systems Configurations: Prepare the systems with the base configurations such as users, packages, security configurations, network setup etc. Tech Stack: install and configure services such as apache, tomcat, middle wares, setup cron jobs, install and configure databases etc. Application: Deploy the application code on top of the tech stack configured. This is where the code written by your team gets deployed with relevant configurations. Change Management Configurations made during the initial setup do not remain do not last for a life time. Infrastructure is in the constant state of flux and evolves over time. Change management involves, Updating configurations parameters across a class of servers eg. update port that web server is running on. Deploying new versions of the application code, push security patches etc, install additional services. Chef serves as a excellent tool for Configuration Management as well as Change Management. And along with tools such as AWS Opsworks, Cloud Plugins, Vagrant, Terraform it could also automate provisioning of servers too. However chef as a tool by itself does have an ability to provision and comes in to play once the Operating System is installed and chef agent is setup. If you are looking for a tool which could also provision servers, and do it effectively, you should consider Ansible.","title":"Infrastructure Life Events and Chef"},{"location":"01_introduction/#evolution-of-configuration-management","text":"The need for managing configurations and ongoing changes had been a challenge which has seen various approaches. Lets have a look at the evolution of configuration management,","title":"Evolution of Configuration Management"},{"location":"01_introduction/#manual","text":"As systems engineers, we almost always begin configuring systems by hand, in a ad hoc manner. This approach is the easiest, and useful when you have only a handful of systems to manage, simple configurations, and where you do not have repeatable tasks or updates. However, as you start growing, this crude approach quickly gets out of control. It also involves manual processes, which mandates a operator to be present, and is prone to errors or omissions.","title":"Manual"},{"location":"01_introduction/#scripts","text":"Scripts allow one to take a sequence of commands to run and put it in a procedural program. Whenever there is need to repeat the process, scripts come in very handy. Some of the popular scripting languages amongst the systems personnel include shell/bash, perl, python, ruby or powershell. Scripts are almost always the first approach towards automating manual tasks. However, scripts are not scalable or flexible enough to manage a sophisticated infrastructure spanning across multitude of environments or the ones involving multiple different operating systems etc.","title":"Scripts"},{"location":"01_introduction/#configuration-management-and-software-configuration-management","text":"Software Configuration Management is referred to often with context of Revision Control which is about tracking changes to the application code. This is just one part of a larger field of Configuration Management.","title":"Configuration Management and  Software Configuration Management"},{"location":"01_introduction/#golden-images-templates","text":"Golden images, or templates, or simply os images, are probably the quickest way to deploy servers complete with configurations, specially in virtual or cloud environments. Images are nothing but pre baked templates with operations system files, applications, and configurations. Take any cloud provider, and one of the first components to choose while you provision a server is the images. A lot of organizations these days package their products in the form of images such as ova, vmdk or even vagrant's box format. However images have one major problem i.e. change management. Every time there is an update, even a single line change, one needs to build a new image. Not only this complete system image needs to be distributed but also existing systems need to be replaced with the new image. Imagine doing that in a dynamic environment involving frequent updates across hundreds of servers. That could get too cumbersome. And thats where the need to come up with a new approach.","title":"Golden Images/ Templates"},{"location":"01_introduction/#infrastructure-as-a-code","text":"\"Infrastructure as a Code\" or \"Programmable Infrastructure\" is where today's generation tools such as Puppet, Chef, Ansible, Salt fit in. These tools essentially allow one to write the state of the infrastructure using a higher level descriptive language and store it as a code. Since this is a code, one could bring in the best practices that developers have been following for years e.g. using revision control systems, use of sophisticated editors, test driven development, peer programming etc. You could even build the complete infrastructure from scratch in case of a disaster, as long as you have the code repository, compute resources and data backups in place. Since this code is written in a simple declarative syntax, it is self documenting and offers visibility to all stakeholders into the way infrastructure is built and configured. Approach Advantages Disadvantages Manual \\pbox{5cm}{simple} \\pbox{5cm}{ad hoc, error prone, inconsistent, not repeatable} Scripts \\pbox{5cm}{repeatable, automated} \\pbox{5cm}{procedural, not scalable, inflexible} Images \\pbox{5cm}{repeatable, automated} \\pbox{5cm}{size, change management is not easy} Infrastructure as a Code \\pbox{5cm}{repeatable, flexible, scalable, automated, consistent} \\pbox{5cm}{agent based, learning curve}","title":"Infrastructure as a Code"},{"location":"01_introduction/#why-to-use-chef","text":"Now that we have started discussion on Infrastructure as a Code, specifically chef, lets discuss about the specific features of chef that make it a useful tool for configuration and change management.","title":"Why to use chef ?"},{"location":"01_introduction/#declarative-vs-procedural-approach","text":"Scripts take a procedural approach towards automation. With scripts, we focus on the how part. e.g. how to install a package, how to create a user, how to modify it later, how to do it on a specific platform. And if you would want to add a support for another platform, you may have to add additional procedure and write a conditional to check for the platform and call the relevant code. This involves a lot of efforts. On the other hand, chef takes a declarative approach towards automation. With chef, our focus changes from how part to what . Instead of writing procedures, we start using a simple declarative syntax to define the desired state of infrastructure. Let me explain this with an analogy. Lets say we want to build a house. When we set out to do so, we hire a contractor, who in turns has a team of construction workers who know how to build it brick by brick. They do all the hard work to bring our house into a reality. Thats the how part. On the other hand, you have a Architect. Lets take a moment and think about what he or she does. An Architect creates a plan, a blue print, which is nothing but a description of how your house should look like. The architect envisions the end state of your house, thinks about what should it consists of, breaks it down into components, and starts creating specification for each. He would then stitch it together to create a blueprint of our house, and hands it to the contractor to go and build it. This is the how part. Thats exactly what we would start doing with chef, only difference being, we write the specification for desired state of IT infrastructure.","title":"Declarative vs Procedural Approach"},{"location":"01_introduction/#resource-abstraction-layer","text":"We just learnt about chef allowing us to write the desired state of the infrastructure using a descriptive language. Now this concept is brought into a reality with the its Domain Specific Language(DSL) which consists of a Resource Abstraction Layer (RAL). Lets describe how this works, TODO : Create an image for each step below. chef looks at infrastructure as a collection of entities to manage e.g. package, service, user, network interface etc. It then takes the procedures, the actual logic to manage these entities and bundles it into something called as Providers . Providers are platform specific. That way, each entity may have multiple providers e.g. managing user on linux vs osx vs windows. On top of these procedures, chef creates an abstraction layer. Instead of defining the procedures, it offers the users a simple declarative syntax to define the state of the entity and its properties, in the form of Resources . chef, then does the translation between Resources and Providers, and calls the procedure to put the entity in to the desired state just as described by the user. This behavior allows the users of the chef to create policies stating what which entities should be present or absent, with what properties.","title":"Resource Abstraction Layer"},{"location":"01_introduction/#convergence-and-idempotence","text":"chef reads the resources, calls the relevant providers for the platform it runs on, and ensures the desired state of the resource is achieved. While it does so, it may need to make changes to the system. But what if the resource has already achieved the desired state and needs no further updates? chef has the built in intelligence to know what is the current state of the resource is. Instead of making changes blindly, it first compares the current state of the resource with the desired state, and the makes a decision whether it requires any changes, and if yes, what changes to make. This process is called as convergence. TODO : Draw diagrams, maybe just a flowchart e.g. Lets assume we have written a resource to create a user with a password. user 'xyz' do uid '501' gid '501' home '/home/xyz' password '$1$foYKL0zO$elXbUOb/JjHqS4aI8O25i.' end First time chef applies this resource on the system, the user may not exist. chef detects the current state, compares it with the desired state which mentions it should exist, and finds the configuration drift. It then creates the user with the password to bring the current state to desired state. Lets assume we run chef again to apply the same resource. This time too it will compare the desired state with current state. Since the user is already present with the password provided, it deems no changes necessary. Instead of attempting to create the user again, it will skip the resource and move on to the next one. Lets assume we updated the password information for the user in our code description of the resource, and excute chef. This time, while comparing the current state with desired state, it detects that the user is present, but the password is updated. It does not attempt to create a user, but only changes one property i.e. password. Idempotence is a useful property to ensures that chef maintains the state of the infrastructure such that its always in the policy. This also makes change management easier as one could keep running chef as a service which invokes itself at regular intervals, pulls the changes, and apply only what is changed.","title":"Convergence and Idempotence"},{"location":"01_introduction/#centralized-configuration-management-system","text":"A typical installation of chef involves a chef Master, which is a centralized management console and Agents runnings on every node managed. Any changes to nodes have to go through the chef Master. This streamlines the process of pushing updated. Instead of iterating over a list of hosts using a for loop or other such methods, or logging into each system to make changes, all you need to do is push updates to chef Server, from where those are automatically propogated to the nodes. TODO","title":"Centralized Configuration Management System"},{"location":"01_introduction/#pull-approach","text":"While chef offers a centralized management approach, it works unlike most client server schemes. Instead of pushing updates to the nodes from master, its the duty of chef agent to go the master, pull changes, and apply. Pull method offers more flexibility and scalability for the following reasons, Each node could decide how frequently or infrequently it should update. Some systems need frequent updates, where as others need not be updated for weeks. This could be controlled at per client level. No need to manage inventory and connection details on the master. Nodes could come and go, and could be configured based on dynamic rules to classify them based on certain property e.g. host names, environments, or even hardware addresses. With push based approach, master must have a ability reach out and connect to each node managed in order to configure it. A lot of times you may have a master on a cloud or in a separate data center than nodes being managed, which could be behind a firewall or NAT device in a private network. In case of pull method, as long as the master is available on a well known address, and is reachable from the nodes, configurations can be pulled and applied.","title":"Pull Approach"},{"location":"01_introduction/#code-vs-data","text":"A lot of applications that we configure on our servers are generic eg. apache, tomcat, mysql, mongo. These applications have a install base of hundreds of thousands of servers, used by organizations across the globe. Ever wondered how these become specific to your environment ? Even though you use the same apache web server used by many others, its how you configure it makes the difference. Even in single organization, you may have a apache server which behaves differently in different environment based on the configuration profile created. The process of setting up an application involves, Installing the generic application either from a source, package or a repository. Adding data. This where you set configuration parameters e.g. port, user, max connections, webroot for apache. Start, enable the service. chef allows separation of code and data. Using chef's DSL, we write infrastructure code to install packages start services etc. Code is generic. chef's attributes templates, along with dat bags and attribute precedence rules provide a way to create different configuration profiles specific to different nodes, environments, platforms etc.","title":"Code vs Data"},{"location":"01_introduction/#shared-library-of-infrastructure-code","text":"With chef's ability to separate code and configuration data, the declarative code that you write in the form of modules with chef becomes generic enough to be shared and be reused. And since this code is in the version control, hosted services such as github offer the perfect means to publish this code. As you start writing code with chef, you would discover about chef forge, a library of community written modules. At the time of writing, there are more than 4000 modules available on chef forge. Similar to a lot of open source code, you need not re invent the wheel. For most open source applications, you would find very sophisticated modules which you could use without even single line change. Download the modules, install it on your own chef master, add configuration profile, and off you go.","title":"Shared Library of Infrastructure Code"},{"location":"01_introduction/#cloud-integrations","text":"With emergence of cloud, computing is moving towards the utility model. More and more organizations have already migrated or contemplating to migrate a partial or whole of their computing setup to cloud. And with that happening, which ever automation tool that you would consider, needs to have a close integration with the cloud platform that you plan to use. Provisioning of infrastructure components before chef comes in and starts configuring There are two ways chef provides a way for this, Through library of custom resources/libraries which allow one to write provisioning of cloud components in the form of resources. Cloud specific tools e.g. Cloudformation on AWS or Heat on Openstack are some of the tools which help provision components which are specific to that cloud and then call chef to do the configurations. Third party tools such as Vagrant, Terraform have in turn ability to talk to multiple cloud providers. These tools typically provision servers on the cloud and then hand it off to chef for configurations.","title":"Cloud Integrations"},{"location":"01_introduction/#iterative-approach-to-automation","text":"However convinced you are with chef, scrapping your existing automation tool overnight for a shiny new tool may have unknown risks attached. More over, it may could be challenging to get a buy in from your management to invest in time, money and resources to implement a new solution without showing them the value. With chef, you could take a iterative approach towards automation. You could start with a single application, or even a single entity such as a system user to manage. Once you see the value, show it to all stake holders, get a buy in and move to the next application, one at a time.","title":"Iterative Approach to Automation"},{"location":"01_introduction/#device-support","text":"Managing configurations on systems running common operating systems such as windows, linux, os x, where chef agent application can be installed is easy. Its a completely different beast when it comes to managing configurations on devices running their own specialized version of operating systems/firmwares. Examples are configuring CISCO's network switches routers, EMC's storage array. Along with programmable infrastructures, new concepts such as Software Defined Networking(SDN) and Software Defined Storage(SDS) are taking root and changing the way devices are being managed. chef supports managing devices in two ways, Devices that are based on linux and have chef agent ported to run on those can be configured the same way as other generic systems. Sub set of devices that do not have chef agent can still be configured with chef's device support over ssh/telnet. For such devices, chef uses push instead of pull approach.","title":"Device Support"},{"location":"01_introduction/#audit-and-compliance","text":"With ability to define the state of the infrastructure components as a code and then converge, one could easily codify the infrastructure policies and have them enforced. chefs ability to test, log changes, and reporting mechanisms help keeping a trail of the state of the systems and its components over time and track who made changes, when, if there are any nodes which have fallen out of policy etc.","title":"Audit and Compliance"},{"location":"01_introduction/#when-to-use-chef","text":"You should consider using chef for the following purposes, Configuration Management + Change Management: You have many nodes to deploy with changes happening often. You need to update the nodes and applications running on those often. Compliance and Audit : When your organization has to comply to policies and you need an ability to convert those policies into a code which would auto correct and bring the nodes into the policy in case of configuration drifts. You also need to audit the systems regularly and prepare reports to find out which nodes have drifted away from the policy etc. as well as mitigate such issues. Software Delivery : If you are in business of building software and delivering as ova images or similar, chef is better approach to deliver the product and push updates to it.","title":"When to Use chef ?"},{"location":"01_introduction/#who-is-it-for","text":"Systems Administrators/Engineers who are managing systems at scale and need to install, configure, patch, monitor and maintain systems and prepared reports for. Application Operations Engineers who are responsible for installing, configuring, integrating, monitoring, maintaining application infrastructures. Build and release engineers who are in charge of setting up environments for CI/CD cycles, as well as deploy/release applications to production environments. Network Engineers who configure and maintain networking devices such as CISCO Routers and Switches at scale. Storage Administrators who configure and maintain storage devices. Developers who are building application delivery to their customers. Also as users of the develops tools, developers may need to change application properties for the environments that they create/use.","title":"Who is it for?"},{"location":"01_introduction/#what-chef-is-not","text":"Graphical Management Tool (e.g. SCCM): If you are looking for a tool which would allow you to manage everything through a graphical interface without writing any code or without ever having to use an editor, well chef is not the tool for you. I have come across many engineers, who say \"well, the capabilities of chef sounds great, but can I do all of this using a GUI where I can just click click and get things done.... ? \" Well, its infrastructure as a code is what we are talking about. Even though enterprise chef chef offers a nice GUI, its mostly for reporting and classifications. Since I started using chef and similar tools, I have been using text editors more often. Automated Testing Tool ( e.g. selenium ): Its not a silver bullet. Its not one solutions to all. I meet a lot of QA folks who have heard that chef would automate everything and you could use it for testing too. Well, there is always a special purpose tool for each task and the application testing is not chef's ball game. Sure chef could help in testing by letting you automate the process of building and configuring a fresh environment to run your tests inside, and give you ability to do it repeatedly. It also gives you a way to test infrastrcuture code. However, its not a test automation tool. Pure Application Deployment and Orchestration Tool: Even though chef has been talking about application orchestration, if you are looking for a tool purely for application deployments, rolling updates, canary releases, orchestrated deployments over multiple hosts, you have tools which do it better. A few tools I could suggest you for application deployment and orchestration are Asible, Capistrano, Code Deploy which are push based, and work better in such scenarios. Agent less Management System: Except for a sub set of network devices, chef mandates running agents on each node being managed. In fact its designed to be heavy on the agent side which is responsible to initiate communication with the master, pull policies, enforce and report back. If you need a agent less management system, chef is not the one. Again, I would suggest using Ansible in such cases, which works over ssh and is agent less. Software Configuration Management(SCM) Tool SCM is a part of the larger Configuration Management and typically refers to the practice of revision/version control. chef is not the tool which does the version control, however it can be used to replicate and manage software configurations across a cluster of nodes. A one stop Devops solutions chef Use Cases/ Customer Stories","title":"What chef is not?"},{"location":"01_introduction/#chef-vs-puppet","text":"","title":"Chef vs Puppet"},{"location":"01_introduction/#chef-vs-ansible","text":"","title":"chef vs Ansible"},{"location":"01_introduction/#chef-vs-docker","text":"","title":"chef vs Docker"},{"location":"03_resources_and_recipies/","text":"Resources and Recipes Resources A resource is a statement of configuration policy that describes the desired state of a node. Block of code, declares the desired state of a node. Resource type\u2014such as package, template, or service. Where a resource represents a piece of the system and the steps that are needed to bring that piece of the system from its current state into the desired state. Recipes Collection of resources in a single file is called recipes. Recipes must be stored in a cookbook. One recipe may be included in another recipe. May use the results of a search query and read the contents of a data bag (including an encrypted data bag) Recipe must be added to a run-list before it can be used by the chef-client Is always executed in the same order as listed in a run-list Writing our First recipe Lets start creating a recipe file named as base.rb , with the following resource specification - Creating user - deploy - Removing user - dojo - Installing packages - tree, git, ntp, wget, unzip - Add content to motd file - Start ntp service Before Writing a recipe lets have a look of available resources here [^chef_resources] to build of recipe. Our recipe start with creating a user resources, for creating a user called deploy user 'deploy' do action :create end The above resource will create only user deploy to add more information to user resources, click here [^user_resources] Let us create password for our user deploy , which need to be encrypted. In terminal use this command and enter paswword twice to create a encrypted password openssl passwd -l user 'deploy' do uid 5001 home '/home/deploy' action :create password '$1$Ze1eJK3R$j5I0NRP5WxbZAaeXcfYW7/' end Syntax Check To check the syntax of ruby file we use ruby -c <file_name.rb> where -c is used to \"check syntax only\". ruby -c base.rb Execute Recipe with Chef Client in Local Mode We will be using Chef-client command with --local-mode or -z to run in localhost(chef workstation). chef-client --local-mode --log_level info <file_name.rb> or chef-client -z -l <file_name.rb> In the above we use --log_level info info or -l to get the detailed information on chef-client run. Using Why (Dry) Run Before applying recipe directly we will be using dry run mode to check what this recipe would do To use dry run and check what this recipe will do, we could use --why-run or -w with chef-client command. chef-client --local-mode --log_level info --why-run <file_name.rb> or chef-client -z -l -w <file_name.rb> By running chef-client -z -l -w base.rb tells that user deploy would be created, and not really created, because of why run mode. Running our first recipe After checking with dry run, we can apply our recipe to the local node. chef-client --local-mode --log_level info base.rb or chef-apply base.rb What it does? It creates user deploy with specified UID and home directory in local machine. Run id deploy to check the details of user deploy. Idempotence Lets run chef-client again to reapply with same options chef-client -z -l base.rb What happened when we run again the chef-client command? It checks for the presence of user deploy and hence it Skipped executing user resources. This is how, idempotent of chef works. LAB Exercises We created user deploy now let us add the remaining resources to our base.rb recipe. - Removing user - dojo - Installing packages - tree, git, ntp, wget, unzip - Add content to motd file - Start ntp service Common Functionality Resources can have some common functionality like sharing properties, conditionals and relative actions. Actions action :nothing The above common functionality can be used with any resource block to do nothing until notified by another resource to take action. Notifications This property is used to listens to other resources in the resource collection and then takes actions based on the notification type ( notifies or subscribes ). The syntax for notifies is: notifies :action, 'resource[name]', :timer Timers A timer specifies the point during the chef-client run at which a notification is run. :before Specifies that the action on a notified resource should be run before processing the resource block in which the notification is located. :delayed Default. Specifies that a notification should be queued up, and then executed at the very end of the chef-client run. :immediate, :immediately Specifies that a notification should be run immediately, per resource notified. Resource with Guards To prevent the execute command from running again and again and providing idempotent to it, we use gaurds one of the common functionality along with the resource. Gaurds The following properties can be used to define a guard that is evaluated during the execution phase of the chef-client run: not_if - Prevent a resource from executing when the condition returns true. only_if - Allow a resource to execute only if the condition returns true. Click here [^deploy_facebooc] for deploy_facebooc.rb recipe for common functionality, as shown below package ['libsqlite3-dev', 'sqlite3'] execute 'download_facebooc_from_source' do command 'wget https://github.com/jserv/facebooc/archive/master.zip' cwd '/opt' user 'root' creates '/opt/master.zip' notifies :run, 'execute[extract_facebook_app]', :immediately end execute 'extract_facebook_app' do command 'unzip master.zip && touch /opt/.facebooc_compile' cwd '/opt' user 'root' action :nothing end execute 'compile_facebooc' do command 'make all && rm /opt/.facebooc_compile' cwd '/opt/facebooc-master' user 'root' only_if 'test -f /opt/.facebooc_compile' action :run end execute 'run_facebooc' do command 'bin/facebooc 16000 &' cwd '/opt/facebooc-master' user 'root' not_if 'netstat -an | grep 16000 | grep -i listen' action :run end [^chef_resources]: Chef Resources - https://docs.chef.io/resource.html [^user_resources]: User Resources - https://docs.chef.io/resource_user.html [^deploy_facebooc]: Deploy_Facebooc Recipie - https://gist.github.com/initcron/eff10a8e5bde59b356a485539579d634","title":"Resources and Recipes"},{"location":"03_resources_and_recipies/#resources-and-recipes","text":"","title":"Resources and Recipes"},{"location":"03_resources_and_recipies/#resources","text":"A resource is a statement of configuration policy that describes the desired state of a node. Block of code, declares the desired state of a node. Resource type\u2014such as package, template, or service. Where a resource represents a piece of the system and the steps that are needed to bring that piece of the system from its current state into the desired state.","title":"Resources"},{"location":"03_resources_and_recipies/#recipes","text":"Collection of resources in a single file is called recipes. Recipes must be stored in a cookbook. One recipe may be included in another recipe. May use the results of a search query and read the contents of a data bag (including an encrypted data bag) Recipe must be added to a run-list before it can be used by the chef-client Is always executed in the same order as listed in a run-list","title":"Recipes"},{"location":"03_resources_and_recipies/#writing-our-first-recipe","text":"Lets start creating a recipe file named as base.rb , with the following resource specification - Creating user - deploy - Removing user - dojo - Installing packages - tree, git, ntp, wget, unzip - Add content to motd file - Start ntp service Before Writing a recipe lets have a look of available resources here [^chef_resources] to build of recipe. Our recipe start with creating a user resources, for creating a user called deploy user 'deploy' do action :create end The above resource will create only user deploy to add more information to user resources, click here [^user_resources] Let us create password for our user deploy , which need to be encrypted. In terminal use this command and enter paswword twice to create a encrypted password openssl passwd -l user 'deploy' do uid 5001 home '/home/deploy' action :create password '$1$Ze1eJK3R$j5I0NRP5WxbZAaeXcfYW7/' end","title":"Writing our First recipe"},{"location":"03_resources_and_recipies/#syntax-check","text":"To check the syntax of ruby file we use ruby -c <file_name.rb> where -c is used to \"check syntax only\". ruby -c base.rb","title":"Syntax Check"},{"location":"03_resources_and_recipies/#execute-recipe-with-chef-client-in-local-mode","text":"We will be using Chef-client command with --local-mode or -z to run in localhost(chef workstation). chef-client --local-mode --log_level info <file_name.rb> or chef-client -z -l <file_name.rb> In the above we use --log_level info info or -l to get the detailed information on chef-client run.","title":"Execute Recipe with Chef Client in Local Mode"},{"location":"03_resources_and_recipies/#using-why-dry-run","text":"Before applying recipe directly we will be using dry run mode to check what this recipe would do To use dry run and check what this recipe will do, we could use --why-run or -w with chef-client command. chef-client --local-mode --log_level info --why-run <file_name.rb> or chef-client -z -l -w <file_name.rb> By running chef-client -z -l -w base.rb tells that user deploy would be created, and not really created, because of why run mode.","title":"Using Why (Dry) Run"},{"location":"03_resources_and_recipies/#running-our-first-recipe","text":"After checking with dry run, we can apply our recipe to the local node. chef-client --local-mode --log_level info base.rb or chef-apply base.rb What it does? It creates user deploy with specified UID and home directory in local machine. Run id deploy to check the details of user deploy.","title":"Running our first recipe"},{"location":"03_resources_and_recipies/#idempotence","text":"Lets run chef-client again to reapply with same options chef-client -z -l base.rb What happened when we run again the chef-client command? It checks for the presence of user deploy and hence it Skipped executing user resources. This is how, idempotent of chef works.","title":"Idempotence"},{"location":"03_resources_and_recipies/#lab-exercises","text":"We created user deploy now let us add the remaining resources to our base.rb recipe. - Removing user - dojo - Installing packages - tree, git, ntp, wget, unzip - Add content to motd file - Start ntp service","title":"LAB Exercises"},{"location":"03_resources_and_recipies/#common-functionality","text":"Resources can have some common functionality like sharing properties, conditionals and relative actions.","title":"Common Functionality"},{"location":"03_resources_and_recipies/#actions","text":"action :nothing The above common functionality can be used with any resource block to do nothing until notified by another resource to take action.","title":"Actions"},{"location":"03_resources_and_recipies/#notifications","text":"This property is used to listens to other resources in the resource collection and then takes actions based on the notification type ( notifies or subscribes ). The syntax for notifies is: notifies :action, 'resource[name]', :timer","title":"Notifications"},{"location":"03_resources_and_recipies/#timers","text":"A timer specifies the point during the chef-client run at which a notification is run. :before Specifies that the action on a notified resource should be run before processing the resource block in which the notification is located. :delayed Default. Specifies that a notification should be queued up, and then executed at the very end of the chef-client run. :immediate, :immediately Specifies that a notification should be run immediately, per resource notified.","title":"Timers"},{"location":"03_resources_and_recipies/#resource-with-guards","text":"To prevent the execute command from running again and again and providing idempotent to it, we use gaurds one of the common functionality along with the resource. Gaurds The following properties can be used to define a guard that is evaluated during the execution phase of the chef-client run: not_if - Prevent a resource from executing when the condition returns true. only_if - Allow a resource to execute only if the condition returns true. Click here [^deploy_facebooc] for deploy_facebooc.rb recipe for common functionality, as shown below package ['libsqlite3-dev', 'sqlite3'] execute 'download_facebooc_from_source' do command 'wget https://github.com/jserv/facebooc/archive/master.zip' cwd '/opt' user 'root' creates '/opt/master.zip' notifies :run, 'execute[extract_facebook_app]', :immediately end execute 'extract_facebook_app' do command 'unzip master.zip && touch /opt/.facebooc_compile' cwd '/opt' user 'root' action :nothing end execute 'compile_facebooc' do command 'make all && rm /opt/.facebooc_compile' cwd '/opt/facebooc-master' user 'root' only_if 'test -f /opt/.facebooc_compile' action :run end execute 'run_facebooc' do command 'bin/facebooc 16000 &' cwd '/opt/facebooc-master' user 'root' not_if 'netstat -an | grep 16000 | grep -i listen' action :run end [^chef_resources]: Chef Resources - https://docs.chef.io/resource.html [^user_resources]: User Resources - https://docs.chef.io/resource_user.html [^deploy_facebooc]: Deploy_Facebooc Recipie - https://gist.github.com/initcron/eff10a8e5bde59b356a485539579d634","title":"Resource with Guards"},{"location":"04_cookbooks/","text":"Cookbook and Run_list In the previous chapter we gone through resources and recipes, now let us go through Cookbook and Run_list in this chapter. What is Cookbook? Cookbook contains configuration and policy which are created using Ruby as its reference language. Cookbook is created with desired scenario in mind and contains required components to support the final scenario of a system. Cookbook contains collection of various components as follows, Components Description Recipes \\pbox{12cm}{Collection of resources in a single file is called recipes. Recipes are stored in a cookbook. Recipe must be added to a run-list before it can be used by the chef-client. Is always executed in the same order as listed in a run-list.} Attributes \\pbox{12cm}{Attributes are used to override the default settings of the node.For each cookbook, attributes in the default.rb file are loaded first, and then additional attribute files (if present) are loaded in lexical sort order.} Files \\pbox{12cm}{Distributing any type of files to nodes, these are static files} Templates \\pbox{12cm}{A template is a file written in markup language that uses Ruby statements to solve complex configuration scenarios, and to update dynamic values.} Cookbook Versions \\pbox{12cm}{A cookbook version is used to maintain a various version of same file with different functionality. A version may exist for many reasons, such as ensuring the correct use of a third-party component, updating a bug fix, or adding an improvement.} Community Cookbooks Chef Maintained Cookbooks Chef maintains a collection of cookbooks that are widely used by the community. Community Cookbooks The community has authored thousands of cookbooks, ranging from niche cookbooks that are used by only a few organizations to cookbooks that are some of the most popular and are used by nearly everyone. Chef Generate chef generate is a part of chef-dk and this command is used to generate a set of file system. Which can be used as a template. To know more about chef generate you can check with the man page, chef generate Usage: chef generate GENERATOR [options] Available generators: app Generate an application repo cookbook Generate a single cookbook recipe Generate a new recipe attribute Generate an attributes file template Generate a file template file Generate a cookbook file lwrp Generate a lightweight resource/provider repo Generate a Chef code repository policyfile Generate a Policyfile for use with the install/push commands generator Copy ChefDK's generator cookbook so you can customize build-cookbook Generate a build cookbook for use with Delivery Chef Generate - App vs Cookbook There are two methods to create code. Traditional approach has been to generate one repository per cookbook. The new approach is to generate one repository per Application, with cookbooks for each component e.g. a repo for web-app with cookbooks for tomcat, java, mysql, deployment. This method also uses a common test kitchen environment etc. To find more information on comparison between App and Cookbook approach, refer to this blog [^devopsguru_blog]. Example of generating a app is chef generate app <app_repo_name> Example of generating a single cookbook is chef generate cookbook <cookbook_name> Generating App and Cookbooks to setup Webapp Let us generate a repo for our application named \"myapp\". Starts with creating a sysfoo repo for our application. chef generate app sysfoo Let us create a first cookbook for our tomcat application. Inside app repo create a cookbooks for tomcat along with its prerequisite cookbook java cd sysfoo chef generate cookbook cookbooks/java chef generate cookbook cookbooks/tomcat App repo and cookbooks are created. Java Cookbook Repo for java cookbook is generated now add resources to our cookbook. create a recipe to install epel-release and java-1.7.0-openjdk . In myapp/cookbooks/java/recipes/default.rb create a default recipe with the following content. package 'epel-release' do action :install end package 'java-1.7.0-openjdk' do action :install end LAB Exercise - Tomcat Cookbook Cookbook for tomcat is already been generated . Add one recipe install.rb to install tomcat and tomcat-webapps . Add another recipe service.rb to start a tomcat service . Creating Local Environment to Test the Code We have created cookbooks for Java and Tomcat and written reipes to install and configure tomcat. Before we uploade this code to the Chef Server and apply it at scale, its important that we test these recipes locally. Every subsequent change to the recipes need to be tested as well. We may also need to test our code on multiple different platforms. Test kitchen offers us a way to create local test environments, apply the code and also execute automated tests to validate that our code works. It could be used for Local development to create portable, use and throw test environments. Functional and Integration tests which could be triggered automatically as part of Continuous Integration environments. Creating Test Kitchen Configuration Test Kitchen comes with a configuration file .kitchen.yml . We have one file for each App and cookbooks. We would edit our top level .kitchen.yml file available at sysfoo/.kitchen.yml Make sure it matches the following config --- driver: name: docker provisioner: name: chef_zero always_update_cookbooks: true verifier: name: inspec platforms: - name: centos-6.8 driver_config: image: codespaces/chef-node-centos-6 forward: - 8080:8080 suites: - name: default run_list: - recipe[sysfoo::default] verifier: inspec_tests: - test/recipes attributes: Once created, check the current status of the environment by running , cd /workspace/sysfoo/ kitchen list TIP: Use yamllint.com to validate .kitchen.yaml if you get an error after running kitchen list Create a Local Environment with Docker Local environment for testing is created using docker, we will be uing \".kitchen.yml\" for creating a test environment. Once the .kitchen.yml is updated we can create kitchen using kitchen create command, from the directory where .kitchen.yml file exists. kitchen create It creates a docker container with centos-6.8 . kitchen list To list the available instances and their information. Adding recipe to run_list Once the test environment created we need to add recipes to the run_list for testing it. Add both java and tomcat recipes to run_list in .kitchen.yml . java::install tomcat::install tomcat::service suites: - name: default run_list: - recipe[java::install] - recipe[tomcat::install] - recipe[tomcat::service] Apply Chef Cookbooks Once the instance is created it can be converged along with the run_list specified in .kitchen.yml kitchen converge It will install chef and then will apply run_list to the instances. To verify, Login and check for java installation and version. kitchen login Logins to docker instance created by kitchen. which java java -version which tomcat service tomcat status Destroying and Converging If you wish to re create the environment from scratch, use kitchen destroy followed by kitchen converge kitchen destroy kitchen list kitchen converge Run converge command directly to create a instance and then converge it and apply run_list to it. Verify the converge by visiting http://ipaddress:8080 for tomcat homepage. Simplifying Run_list Lets make recipes simplified. From this recipie ./myapp/cookbooks/tomcat/recipes/default.rb call all other recipes. # # Cookbook Name:: tomcat # Recipe:: default # # Copyright (c) 2017 The Authors, All Rights Reserved. include_recipe 'java' # we can also call the above recipe as # include_recipe 'java::default' include_recipe 'tomcat::install' include_recipe 'tomcat::service' Now change the run_list in ./sysfoo/test/.kitchen.yml and add only tomcat::default suites: - name: default run_list: - recipe[tomcat] Once added, now converge again. You could get error because of java cookbook not found, but tomcat includes java in run_list. Now to add depended java , add java dependency entry in the metadata file ./myapp/cookbooks/tomcat/metadata.rb . name 'tomcat' maintainer 'The Authors' maintainer_email 'you@example.com' license 'all_rights' description 'Installs/Configures tomcat' long_description 'Installs/Configures tomcat' version '0.1.0' depends 'java' Managing Files We will need to manage configurations eg. tomcat.conf since chef is a centralized configuration management system, we will keep the files centrally in cookbooks, which will then be copied to all managed nodes Generating Files Create tomcat.conf to manage the configuration of tomcat in all nodes. Use chef generate file in tomcat cookbook directory. chef generate file cookbooks/tomcat tomcat.conf Now ./sysfoo/cookbooks/tomcat/files/default/tomcat.conf is generated using chef. Update tomcat.conf with the following content to manage tomcat. TOMCAT_CFG_LOADED=\"1\" JAVA_HOME=\"/usr/lib/jvm/jre\" JAVA_OPTS=\"-Xms64m -Xmx128m -XX:MaxPermSize=128M \\ -Djava.security.egd=file:/dev/./urandom\" CATALINA_BASE=\"/usr/share/tomcat\" CATALINA_HOME=\"/usr/share/tomcat\" JASPER_HOME=\"/usr/share/tomcat\" CATALINA_TMPDIR=\"/var/cache/tomcat/temp\" TOMCAT_USER=\"tomcat\" SECURITY_MANAGER=\"false\" SHUTDOWN_WAIT=\"30\" SHUTDOWN_VERBOSE=\"false\" CATALINA_PID=\"/var/run/tomcat.pid\" {todo} TIP: files/default Recipe to manage cookbook files Now to manage tomcat.conf create a recipe called config.rb in tomcat cookbook. Use chef generate recipe to generate recipe intomcat cookbook. chef generate recipe cookbooks/tomcat config Now ./myapp/cookbooks/tomcat/recipes/config.rb is generated. Add the following content into config.rb cookbook_file '/etc/tomcat/tomcat.conf' do source 'tomcat.conf' owner 'tomcat' group 'tomcat' mode 0644 action :create end Refreshing Services We can use notifies with timers to trigger another resources in a recipes. Let us add an entry to notifies tomcat service in config.rb cookbook_file '/etc/tomcat/tomcat.conf' do source 'tomcat.conf' owner 'tomcat' group 'tomcat' mode 0644 action :create notifies :restart, 'service[tomcat]', :delayed end In the above service tomcat will be restarted if there is any change in cookbook_file resource. once config.rb recipe is created add an entry for run_list in default.rb of tomcat cookbook for applying it to nodes, as follows. include_recipe 'tomcat::config' Now kitchen converge and check logs to see service tomcat is being restarted for every change made in tomcat.conf file. Now verify by logging into docker instance using kitchen login . [^devopsguru_blog]: Devopsguru Blog - http://devopsguru.tumblr.com/post/147717124737/chef-generate-app-vs-chef-generate-cookbook-vs","title":"Cookbooks"},{"location":"04_cookbooks/#cookbook-and-run_list","text":"In the previous chapter we gone through resources and recipes, now let us go through Cookbook and Run_list in this chapter.","title":"Cookbook and Run_list"},{"location":"04_cookbooks/#what-is-cookbook","text":"Cookbook contains configuration and policy which are created using Ruby as its reference language. Cookbook is created with desired scenario in mind and contains required components to support the final scenario of a system. Cookbook contains collection of various components as follows, Components Description Recipes \\pbox{12cm}{Collection of resources in a single file is called recipes. Recipes are stored in a cookbook. Recipe must be added to a run-list before it can be used by the chef-client. Is always executed in the same order as listed in a run-list.} Attributes \\pbox{12cm}{Attributes are used to override the default settings of the node.For each cookbook, attributes in the default.rb file are loaded first, and then additional attribute files (if present) are loaded in lexical sort order.} Files \\pbox{12cm}{Distributing any type of files to nodes, these are static files} Templates \\pbox{12cm}{A template is a file written in markup language that uses Ruby statements to solve complex configuration scenarios, and to update dynamic values.} Cookbook Versions \\pbox{12cm}{A cookbook version is used to maintain a various version of same file with different functionality. A version may exist for many reasons, such as ensuring the correct use of a third-party component, updating a bug fix, or adding an improvement.}","title":"What is Cookbook?"},{"location":"04_cookbooks/#community-cookbooks","text":"Chef Maintained Cookbooks Chef maintains a collection of cookbooks that are widely used by the community. Community Cookbooks The community has authored thousands of cookbooks, ranging from niche cookbooks that are used by only a few organizations to cookbooks that are some of the most popular and are used by nearly everyone.","title":"Community Cookbooks"},{"location":"04_cookbooks/#chef-generate","text":"chef generate is a part of chef-dk and this command is used to generate a set of file system. Which can be used as a template. To know more about chef generate you can check with the man page, chef generate Usage: chef generate GENERATOR [options] Available generators: app Generate an application repo cookbook Generate a single cookbook recipe Generate a new recipe attribute Generate an attributes file template Generate a file template file Generate a cookbook file lwrp Generate a lightweight resource/provider repo Generate a Chef code repository policyfile Generate a Policyfile for use with the install/push commands generator Copy ChefDK's generator cookbook so you can customize build-cookbook Generate a build cookbook for use with Delivery","title":"Chef Generate"},{"location":"04_cookbooks/#chef-generate-app-vs-cookbook","text":"There are two methods to create code. Traditional approach has been to generate one repository per cookbook. The new approach is to generate one repository per Application, with cookbooks for each component e.g. a repo for web-app with cookbooks for tomcat, java, mysql, deployment. This method also uses a common test kitchen environment etc. To find more information on comparison between App and Cookbook approach, refer to this blog [^devopsguru_blog]. Example of generating a app is chef generate app <app_repo_name> Example of generating a single cookbook is chef generate cookbook <cookbook_name>","title":"Chef Generate -  App vs Cookbook"},{"location":"04_cookbooks/#generating-app-and-cookbooks-to-setup-webapp","text":"Let us generate a repo for our application named \"myapp\". Starts with creating a sysfoo repo for our application. chef generate app sysfoo Let us create a first cookbook for our tomcat application. Inside app repo create a cookbooks for tomcat along with its prerequisite cookbook java cd sysfoo chef generate cookbook cookbooks/java chef generate cookbook cookbooks/tomcat App repo and cookbooks are created.","title":"Generating App and Cookbooks to setup Webapp"},{"location":"04_cookbooks/#java-cookbook","text":"Repo for java cookbook is generated now add resources to our cookbook. create a recipe to install epel-release and java-1.7.0-openjdk . In myapp/cookbooks/java/recipes/default.rb create a default recipe with the following content. package 'epel-release' do action :install end package 'java-1.7.0-openjdk' do action :install end","title":"Java Cookbook"},{"location":"04_cookbooks/#lab-exercise-tomcat-cookbook","text":"Cookbook for tomcat is already been generated . Add one recipe install.rb to install tomcat and tomcat-webapps . Add another recipe service.rb to start a tomcat service .","title":"LAB Exercise - Tomcat Cookbook"},{"location":"04_cookbooks/#creating-local-environment-to-test-the-code","text":"We have created cookbooks for Java and Tomcat and written reipes to install and configure tomcat. Before we uploade this code to the Chef Server and apply it at scale, its important that we test these recipes locally. Every subsequent change to the recipes need to be tested as well. We may also need to test our code on multiple different platforms. Test kitchen offers us a way to create local test environments, apply the code and also execute automated tests to validate that our code works. It could be used for Local development to create portable, use and throw test environments. Functional and Integration tests which could be triggered automatically as part of Continuous Integration environments.","title":"Creating Local Environment to Test the Code"},{"location":"04_cookbooks/#creating-test-kitchen-configuration","text":"Test Kitchen comes with a configuration file .kitchen.yml . We have one file for each App and cookbooks. We would edit our top level .kitchen.yml file available at sysfoo/.kitchen.yml Make sure it matches the following config --- driver: name: docker provisioner: name: chef_zero always_update_cookbooks: true verifier: name: inspec platforms: - name: centos-6.8 driver_config: image: codespaces/chef-node-centos-6 forward: - 8080:8080 suites: - name: default run_list: - recipe[sysfoo::default] verifier: inspec_tests: - test/recipes attributes: Once created, check the current status of the environment by running , cd /workspace/sysfoo/ kitchen list TIP: Use yamllint.com to validate .kitchen.yaml if you get an error after running kitchen list","title":"Creating Test Kitchen Configuration"},{"location":"04_cookbooks/#create-a-local-environment-with-docker","text":"Local environment for testing is created using docker, we will be uing \".kitchen.yml\" for creating a test environment. Once the .kitchen.yml is updated we can create kitchen using kitchen create command, from the directory where .kitchen.yml file exists. kitchen create It creates a docker container with centos-6.8 . kitchen list To list the available instances and their information.","title":"Create a Local Environment with Docker"},{"location":"04_cookbooks/#adding-recipe-to-run_list","text":"Once the test environment created we need to add recipes to the run_list for testing it. Add both java and tomcat recipes to run_list in .kitchen.yml . java::install tomcat::install tomcat::service suites: - name: default run_list: - recipe[java::install] - recipe[tomcat::install] - recipe[tomcat::service]","title":"Adding recipe to run_list"},{"location":"04_cookbooks/#apply-chef-cookbooks","text":"Once the instance is created it can be converged along with the run_list specified in .kitchen.yml kitchen converge It will install chef and then will apply run_list to the instances. To verify, Login and check for java installation and version. kitchen login Logins to docker instance created by kitchen. which java java -version which tomcat service tomcat status","title":"Apply Chef Cookbooks"},{"location":"04_cookbooks/#destroying-and-converging","text":"If you wish to re create the environment from scratch, use kitchen destroy followed by kitchen converge kitchen destroy kitchen list kitchen converge Run converge command directly to create a instance and then converge it and apply run_list to it. Verify the converge by visiting http://ipaddress:8080 for tomcat homepage.","title":"Destroying and Converging"},{"location":"04_cookbooks/#simplifying-run_list","text":"Lets make recipes simplified. From this recipie ./myapp/cookbooks/tomcat/recipes/default.rb call all other recipes. # # Cookbook Name:: tomcat # Recipe:: default # # Copyright (c) 2017 The Authors, All Rights Reserved. include_recipe 'java' # we can also call the above recipe as # include_recipe 'java::default' include_recipe 'tomcat::install' include_recipe 'tomcat::service' Now change the run_list in ./sysfoo/test/.kitchen.yml and add only tomcat::default suites: - name: default run_list: - recipe[tomcat] Once added, now converge again. You could get error because of java cookbook not found, but tomcat includes java in run_list. Now to add depended java , add java dependency entry in the metadata file ./myapp/cookbooks/tomcat/metadata.rb . name 'tomcat' maintainer 'The Authors' maintainer_email 'you@example.com' license 'all_rights' description 'Installs/Configures tomcat' long_description 'Installs/Configures tomcat' version '0.1.0' depends 'java'","title":"Simplifying Run_list"},{"location":"04_cookbooks/#managing-files","text":"We will need to manage configurations eg. tomcat.conf since chef is a centralized configuration management system, we will keep the files centrally in cookbooks, which will then be copied to all managed nodes","title":"Managing Files"},{"location":"04_cookbooks/#generating-files","text":"Create tomcat.conf to manage the configuration of tomcat in all nodes. Use chef generate file in tomcat cookbook directory. chef generate file cookbooks/tomcat tomcat.conf Now ./sysfoo/cookbooks/tomcat/files/default/tomcat.conf is generated using chef. Update tomcat.conf with the following content to manage tomcat. TOMCAT_CFG_LOADED=\"1\" JAVA_HOME=\"/usr/lib/jvm/jre\" JAVA_OPTS=\"-Xms64m -Xmx128m -XX:MaxPermSize=128M \\ -Djava.security.egd=file:/dev/./urandom\" CATALINA_BASE=\"/usr/share/tomcat\" CATALINA_HOME=\"/usr/share/tomcat\" JASPER_HOME=\"/usr/share/tomcat\" CATALINA_TMPDIR=\"/var/cache/tomcat/temp\" TOMCAT_USER=\"tomcat\" SECURITY_MANAGER=\"false\" SHUTDOWN_WAIT=\"30\" SHUTDOWN_VERBOSE=\"false\" CATALINA_PID=\"/var/run/tomcat.pid\" {todo} TIP: files/default","title":"Generating Files"},{"location":"04_cookbooks/#recipe-to-manage-cookbook-files","text":"Now to manage tomcat.conf create a recipe called config.rb in tomcat cookbook. Use chef generate recipe to generate recipe intomcat cookbook. chef generate recipe cookbooks/tomcat config Now ./myapp/cookbooks/tomcat/recipes/config.rb is generated. Add the following content into config.rb cookbook_file '/etc/tomcat/tomcat.conf' do source 'tomcat.conf' owner 'tomcat' group 'tomcat' mode 0644 action :create end","title":"Recipe to manage cookbook files"},{"location":"04_cookbooks/#refreshing-services","text":"We can use notifies with timers to trigger another resources in a recipes. Let us add an entry to notifies tomcat service in config.rb cookbook_file '/etc/tomcat/tomcat.conf' do source 'tomcat.conf' owner 'tomcat' group 'tomcat' mode 0644 action :create notifies :restart, 'service[tomcat]', :delayed end In the above service tomcat will be restarted if there is any change in cookbook_file resource. once config.rb recipe is created add an entry for run_list in default.rb of tomcat cookbook for applying it to nodes, as follows. include_recipe 'tomcat::config' Now kitchen converge and check logs to see service tomcat is being restarted for every change made in tomcat.conf file. Now verify by logging into docker instance using kitchen login . [^devopsguru_blog]: Devopsguru Blog - http://devopsguru.tumblr.com/post/147717124737/chef-generate-app-vs-chef-generate-cookbook-vs","title":"Refreshing Services"},{"location":"05_tdd_with_test_kitchen/","text":"TDD with Test Kitchen App test vs Cookbook Test Test configuration can be defined in two different places. One is inside app directory myapp/test/recipes/default_test.rb Another one is inside the cookbooks directory myapp/cookbooks/mycookbook/test/recipes/default_test.rb Inspec vs Serverspec Inspec resources Serverspec resources Creating test file User Resource Add inspec user resource to check for tomcat user unless os.windows? describe user('tomcat') do it { should exist } end end Port Resource Add inspec port resource to verify listening of port 8080 Include protocols for tcp6 describe port(8080) do it { should be_listening } its('protocols') { should include 'tcp6' } end Service Resource Add inspec service resource to verify tomcat service Include installed , enabled and running conditions describe service('tomcat') do it { should be_installed } it { should be_enabled } it { should be_running } end Complete file of /workspace/myapp/test/recipes/default_test.rb is as follows unless os.windows? describe user('tomcat') do it { should exist } end end describe port(8080) do it { should be_listening } its('protocols') { should include 'tcp6' } end describe service('tomcat') do it { should be_installed } it { should be_enabled } it { should be_running } end","title":"TDD with Test Kitchen"},{"location":"05_tdd_with_test_kitchen/#tdd-with-test-kitchen","text":"","title":"TDD with Test Kitchen"},{"location":"05_tdd_with_test_kitchen/#app-test-vs-cookbook-test","text":"Test configuration can be defined in two different places. One is inside app directory myapp/test/recipes/default_test.rb Another one is inside the cookbooks directory myapp/cookbooks/mycookbook/test/recipes/default_test.rb","title":"App test vs Cookbook Test"},{"location":"05_tdd_with_test_kitchen/#inspec-vs-serverspec","text":"Inspec resources Serverspec resources","title":"Inspec vs Serverspec"},{"location":"05_tdd_with_test_kitchen/#creating-test-file","text":"","title":"Creating test file"},{"location":"05_tdd_with_test_kitchen/#user-resource","text":"Add inspec user resource to check for tomcat user unless os.windows? describe user('tomcat') do it { should exist } end end","title":"User Resource"},{"location":"05_tdd_with_test_kitchen/#port-resource","text":"Add inspec port resource to verify listening of port 8080 Include protocols for tcp6 describe port(8080) do it { should be_listening } its('protocols') { should include 'tcp6' } end","title":"Port Resource"},{"location":"05_tdd_with_test_kitchen/#service-resource","text":"Add inspec service resource to verify tomcat service Include installed , enabled and running conditions describe service('tomcat') do it { should be_installed } it { should be_enabled } it { should be_running } end Complete file of /workspace/myapp/test/recipes/default_test.rb is as follows unless os.windows? describe user('tomcat') do it { should exist } end end describe port(8080) do it { should be_listening } its('protocols') { should include 'tcp6' } end describe service('tomcat') do it { should be_installed } it { should be_enabled } it { should be_running } end","title":"Service Resource"},{"location":"06_multi_node_cluster_setup/","text":"Multi Node Cluster In this session we going to simulate a realistic environment with multiple nodes being managed with Chef Server, similar to most of the real world implementations. This would include 3 components, Chef Workstation (Could be your personal PC/Laptop) Chef Server (Hosted or On-Premises ) Chef Clients ('n' number of machines; could be VM, AWS EC2, etc..) Setting up Hosted Chef Server Environment Chef server comes in two flavors * Open Source * Enterprise Enterprise version of chef has two sub types * Hosted * On Premises In terms of features, both on prem and hosted versions are the same. The only difference is whether you use the SaaS solution from Chef, or you want to host it in house. For this workshop, we would be using Hosted Enterprise Chef for the following reasons, Ease of setup : hosted version is a breeze to setup and you have a working chef server setup within minutes Resource Optimization: On Premises version of chef server takes a lot of resources to setup and use e.g. 4GB of RAM with atleast dual core for getting a decent operational version. Thats too much in most learning lab environments. Hosted version takes zero resources to setup. Lets learn how to setup our hosted chef account... Creating an Account Now let us create a account in chef.io to manage our own hosted chef server. Once account is created, verify and login. Now create a organization of your own and then download chef-starter kit. Setting Up Workstation Upload starter kit to the workspace. Its the chef-starter.zip file that you downloaded from chef server. Upload the file to workspace and extract it. You should see chef-repo directory created after being extracted. Change into chef-repo directory created as the outcome of above command and validate workstation by running knife client list The above command will return the orgname-validator client. If it does,you have successufully validated all of following, Workstation software (knife) is installed You have required configurations, authentication keys/credentials to talk to Chef Server Chef Server is setup and ready Workstation is able to communicate with Chef Server. There are no network issues etc. Workstaiton is able to authenticate with Chef Server Workstation has made the API request and displays the results returned by Chef Server Moving knife configs to workspace Copy .chef directory from chef-repo to workspace . mv /workspace/chef-repo/.chef /workspace Alternately you could also create a symbolic link/symlink. From here on all knife commands work from any subdirectory of /workspace. Bootstrapping a Managed Node Now run knife client list to get the list of client associated with the hosted chef-server. In our case we don't have any client as of now, so lets start adding nodes by using knife bootstrap command. From Workstation we need to bootstrap client. In codespaces environment we have pre-built nodes associated with the following IP. Node Name IP Port Mapping node1 app1 177.0.101.10 8081:8080 node2 app2 177.0.101.11 8082:8080 node3 app3 177.0.101.12 8083:8080 node4 lb 177.0.101.13 8084:8080 All nodes are accessible using ssh without password. Lets bootstrap node1 using the following command knife bootstrap node1 --ssh-user devops --sudo -N app1 Here -N is used to define the name of the node that we bootstrap. --ssh-user is used to provide the name of the user in that particular node. Also using --sudo to connect is to provide root previlages for running all the command. app1 is bootstrapped successfully. Now check for the available nodes knife node list Check for the existing status and specified runlist for node1(app1) knife node show app1 Providing configurations to the Node To provide configurations, you would need to upload the cookbooks to chef server and set the run list. Before we do so, we also need to updated the path where knife would look in to find the cookbooks. Edit /workspace/.chef/knife.rb and update cookbook_path from cookbook_path [\"#{current_dir}/../cookbooks\"] to cookbook_path [\"cookbooks\"] Change into chapter6/sysfoo directory on workstation. Upload the cookbooks that we created and tested locally earlier. knife cookbook upload java tomcat Defining Run List for the Node knife node show app1 knife node run_list add app1 \"recipe[tomcat]\" To apply, login to node1 and run chef-client ssh devops@node1 sudo chef-client Managing Chef Client as a Service Lets now start managing chef-client and its configurations through chef cookbooks. We have a special purpose cookbook by name chef-client which allows us to do so. It will, * decide how to run chef-client, eg. cronjob, service etc. * does support various types of service managers e.g. runit, bluepill, supervisord etc. * manages configurations for chef client .eg. how frequently chef-client runs Lets upload chef-client cookbook which is already present if you are using the code repository provides. knife cookbook upload chef-client Did chef-client cookbook get uploaded successfully? If not, observe the error and try to deduct the root cause. Berkshelf Berkshelf is a dependency manager for Chef cookbooks. With it, you can easily depend on community cookbooks and have them safely included in your workflow. You can also ensure that your CI systems reproducibly select the same cookbook versions, and can upload and bundle cookbook dependencies without needing a locally maintained copy. Berkshelf is included in the Chef Development Kit. Now look into the downloaded chef-client cookbook. It has berksfile where the dependent cookbook are mentioned. To run berks command we need to be in the directory where berksfile is located, that is workspace/sysfoo/cookbooks/chef-client Now run install and upload command. cd cookbooks/chef-client berks install; berks upload cd ../.. Lets now add chef-client recipe to the runlist of node1. knife node run_list add app1 \"recipe[chef-client]\" To apply this recipe, login to node1 and run chef client as, ssh devops@node1 sudo chef-client Providing run list while bootstrapping For node1, we did the following, * Bootstrapped the node * Defined run list * Logged in to the node and run chef-client For initial node this was needed as you are learning to apply one concept at a time, and you did not have the cookbooks uploaded on the server. Now that its all ready, you could combine these operations into one by defining the run list, right at the bootstrap time. Lets bootstrap node2 this time with tomcat and java configs knife bootstrap node2 -x devops --sudo -N app2 -r \"recipe[tomcat],recipe[chef-client]\" --run-list is used to specify run-list and by applying recipes to the node at the time of bootstrap. Now verify by visiting host ip with port mapping of 8080 to 8081 for node1 http://ip:8081 and port mapping of 8080 to 8082 for node2 http://ip:8082, where the tomcat application is installed and service is up and running.","title":"Setting up a Multi Node Cluster"},{"location":"06_multi_node_cluster_setup/#multi-node-cluster","text":"In this session we going to simulate a realistic environment with multiple nodes being managed with Chef Server, similar to most of the real world implementations. This would include 3 components, Chef Workstation (Could be your personal PC/Laptop) Chef Server (Hosted or On-Premises ) Chef Clients ('n' number of machines; could be VM, AWS EC2, etc..)","title":"Multi Node Cluster"},{"location":"06_multi_node_cluster_setup/#setting-up-hosted-chef-server-environment","text":"Chef server comes in two flavors * Open Source * Enterprise Enterprise version of chef has two sub types * Hosted * On Premises In terms of features, both on prem and hosted versions are the same. The only difference is whether you use the SaaS solution from Chef, or you want to host it in house. For this workshop, we would be using Hosted Enterprise Chef for the following reasons, Ease of setup : hosted version is a breeze to setup and you have a working chef server setup within minutes Resource Optimization: On Premises version of chef server takes a lot of resources to setup and use e.g. 4GB of RAM with atleast dual core for getting a decent operational version. Thats too much in most learning lab environments. Hosted version takes zero resources to setup. Lets learn how to setup our hosted chef account...","title":"Setting up Hosted Chef Server Environment"},{"location":"06_multi_node_cluster_setup/#creating-an-account","text":"Now let us create a account in chef.io to manage our own hosted chef server. Once account is created, verify and login. Now create a organization of your own and then download chef-starter kit.","title":"Creating an Account"},{"location":"06_multi_node_cluster_setup/#setting-up-workstation","text":"Upload starter kit to the workspace. Its the chef-starter.zip file that you downloaded from chef server. Upload the file to workspace and extract it. You should see chef-repo directory created after being extracted. Change into chef-repo directory created as the outcome of above command and validate workstation by running knife client list The above command will return the orgname-validator client. If it does,you have successufully validated all of following, Workstation software (knife) is installed You have required configurations, authentication keys/credentials to talk to Chef Server Chef Server is setup and ready Workstation is able to communicate with Chef Server. There are no network issues etc. Workstaiton is able to authenticate with Chef Server Workstation has made the API request and displays the results returned by Chef Server","title":"Setting Up Workstation"},{"location":"06_multi_node_cluster_setup/#moving-knife-configs-to-workspace","text":"Copy .chef directory from chef-repo to workspace . mv /workspace/chef-repo/.chef /workspace Alternately you could also create a symbolic link/symlink. From here on all knife commands work from any subdirectory of /workspace.","title":"Moving knife configs to workspace"},{"location":"06_multi_node_cluster_setup/#bootstrapping-a-managed-node","text":"Now run knife client list to get the list of client associated with the hosted chef-server. In our case we don't have any client as of now, so lets start adding nodes by using knife bootstrap command. From Workstation we need to bootstrap client. In codespaces environment we have pre-built nodes associated with the following IP. Node Name IP Port Mapping node1 app1 177.0.101.10 8081:8080 node2 app2 177.0.101.11 8082:8080 node3 app3 177.0.101.12 8083:8080 node4 lb 177.0.101.13 8084:8080 All nodes are accessible using ssh without password. Lets bootstrap node1 using the following command knife bootstrap node1 --ssh-user devops --sudo -N app1 Here -N is used to define the name of the node that we bootstrap. --ssh-user is used to provide the name of the user in that particular node. Also using --sudo to connect is to provide root previlages for running all the command. app1 is bootstrapped successfully. Now check for the available nodes knife node list Check for the existing status and specified runlist for node1(app1) knife node show app1","title":"Bootstrapping a Managed Node"},{"location":"06_multi_node_cluster_setup/#providing-configurations-to-the-node","text":"To provide configurations, you would need to upload the cookbooks to chef server and set the run list. Before we do so, we also need to updated the path where knife would look in to find the cookbooks. Edit /workspace/.chef/knife.rb and update cookbook_path from cookbook_path [\"#{current_dir}/../cookbooks\"] to cookbook_path [\"cookbooks\"] Change into chapter6/sysfoo directory on workstation. Upload the cookbooks that we created and tested locally earlier. knife cookbook upload java tomcat","title":"Providing configurations to the Node"},{"location":"06_multi_node_cluster_setup/#defining-run-list-for-the-node","text":"knife node show app1 knife node run_list add app1 \"recipe[tomcat]\" To apply, login to node1 and run chef-client ssh devops@node1 sudo chef-client","title":"Defining Run List for the Node"},{"location":"06_multi_node_cluster_setup/#managing-chef-client-as-a-service","text":"Lets now start managing chef-client and its configurations through chef cookbooks. We have a special purpose cookbook by name chef-client which allows us to do so. It will, * decide how to run chef-client, eg. cronjob, service etc. * does support various types of service managers e.g. runit, bluepill, supervisord etc. * manages configurations for chef client .eg. how frequently chef-client runs Lets upload chef-client cookbook which is already present if you are using the code repository provides. knife cookbook upload chef-client Did chef-client cookbook get uploaded successfully? If not, observe the error and try to deduct the root cause.","title":"Managing Chef Client as a Service"},{"location":"06_multi_node_cluster_setup/#berkshelf","text":"Berkshelf is a dependency manager for Chef cookbooks. With it, you can easily depend on community cookbooks and have them safely included in your workflow. You can also ensure that your CI systems reproducibly select the same cookbook versions, and can upload and bundle cookbook dependencies without needing a locally maintained copy. Berkshelf is included in the Chef Development Kit. Now look into the downloaded chef-client cookbook. It has berksfile where the dependent cookbook are mentioned. To run berks command we need to be in the directory where berksfile is located, that is workspace/sysfoo/cookbooks/chef-client Now run install and upload command. cd cookbooks/chef-client berks install; berks upload cd ../.. Lets now add chef-client recipe to the runlist of node1. knife node run_list add app1 \"recipe[chef-client]\" To apply this recipe, login to node1 and run chef client as, ssh devops@node1 sudo chef-client","title":"Berkshelf"},{"location":"06_multi_node_cluster_setup/#providing-run-list-while-bootstrapping","text":"For node1, we did the following, * Bootstrapped the node * Defined run list * Logged in to the node and run chef-client For initial node this was needed as you are learning to apply one concept at a time, and you did not have the cookbooks uploaded on the server. Now that its all ready, you could combine these operations into one by defining the run list, right at the bootstrap time. Lets bootstrap node2 this time with tomcat and java configs knife bootstrap node2 -x devops --sudo -N app2 -r \"recipe[tomcat],recipe[chef-client]\" --run-list is used to specify run-list and by applying recipes to the node at the time of bootstrap. Now verify by visiting host ip with port mapping of 8080 to 8081 for node1 http://ip:8081 and port mapping of 8080 to 8082 for node2 http://ip:8082, where the tomcat application is installed and service is up and running.","title":"Providing run list while bootstrapping"},{"location":"07_data_driven_cookbooks_attr_templates/","text":"Data Driven Cookbooks Code vs Data once the data is taken out of the code then cookbook become generic. Generic cookbook can be used with any OS and environments. Reusability helps in reducing tonnes and tonnes of time. Node Object It is the representation of each node on chef server in JSON format. If we run a chef-client it generates a node object in chef server in case of nodes or in workstation ( /nodes/*.json ) in case of running locally in workstation. Attributes It is used to specify a detail about node. - Attributes are used by the chef-client to understand; - The current state of the node - What the state of the node was at the end of the previous chef-client run - What the state of the node should be at the end of the current chef-client run - Attributes are taken in precedence, according to the place where we specify them, as follows; System Defined Attributes OHAI It installs along with chef-client . It helps in getting all the information about nodes Finding information on node with ohai ohai ohai ipaddress ohai hostname ohai memory ohai memory/total ohai cpu/model_name Referring attributes node['ipaddress'] node['hostname'] node['memory']['total'] node['cpu']['model_name'] User Defined Attributes User defined attributes are located in four places as follows Attributes file Recipes Roles Environments Attribute File How the attribute file looks like? Precedence is defined Attribute and its value is defined as per the above format. Now we can access these attributes in recipe or template as shown below. Example template node['tomcat']['config'] do source 'tomcat.conf.erb' owner node['tomcat']['user'] group node['tomcat']['group'] mode '0644' action :create notifies :restart, \"service[#{node['tomcat']['service']}]\", :delayed end Parameterizing Tomcat Configurations Now let us start creating attribute file Use chef generate to create a file in tomcat cookbook chef generate attribute cookbooks/tomcat default It will create a file as follows cookbooks/tomcat/attributes/default.rb Now we add the attributes and its value in default.rb Path: cookbooks/tomcat/attributes/default.rb default['tomcat']['user'] = 'tomcat' default['tomcat']['group'] = 'tomcat' default['tomcat']['config'] = '/etc/tomcat/tomcat.conf' default['tomcat']['packages'] = [ 'tomcat', 'tomcat-webapps' ] default['tomcat']['service'] = 'tomcat' Now call these attributes in the following recipes tomcat::config will be changed as follows cookbook_file node['tomcat']['config'] do source 'tomcat.conf' owner node['tomcat']['user'] group node['tomcat']['group'] mode '0644' action :create notifies :restart, \"service[#{node['tomcat']['service']}]\", :delayed end tomcat::install will be changed as follows package node['tomcat']['packages'] tomcat::service will be changed as follows service node['tomcat']['service'] do action [ :start, :enable] end Now apply it using kitchen converge and then verify using kitchen verify . Platform Specific cookbooks Let us convert our first created base.rb recipe into a cookbook. Create a cookbook using chef generate chef generate cookbook cookbooks/base Now move the base.rb to default.rb of base cookbook. mv /workspace/chapter3/base.rb cookbooks/base/recipes/default.rb Add base::default recipe to the run_list knife node run_list add app1 \"recipe[base]\" Apply on node1 ssh devops@node1 sudo chef-client It fails because the service name for rhel/centos is ntpd and not ntp as like debian. To overcome this we use attribute for platform specific. We use system defined attribute platform_family to do this. Example for ohai platform_family is root@ws:/workspace/myapp# ohai platform_family [ \"debian\" ] root@ws:/workspace/myapp# kitchen login Last login: Thu May 4 05:50:20 2017 from 172.17.0.1 [kitchen@9af3a004e202 ~]$ ohai platform_family [2017-05-04T05:58:19+00:00] INFO: The plugin path /etc/chef/ohai/plugins does not exist. Skipping... [ \"rhel\" ] [kitchen@9af3a004e202 ~]$ logout Connection to localhost closed. root@ws:/workspace/myapp# Now let us create a create a default attribute file for base cookbook using chef generate chef generate attribute cookbooks/base default Now add the following content to attribute file Path: cookbooks/base/attributes/default.rb case node['platform_family'] when 'rhel' default['ntp']['service'] = 'ntpd' else default['ntp']['service'] = 'ntp' end Call the attributes in cookbooks/base/recipes/default.rb recipe service node['ntp']['service'] do action [ :start, :enable ] end Now apply again using kitchen ssh devop@node1 sudo chef-client It is successful now and service is started based on platform. Nano Project - Add some tests for recipes in base cookbook for different platform. Templates A cookbook template is an Embedded Ruby (ERB) template that is used to dynamically generate static text files. Templates are great way to manage configuration files for different environment. ERB or ERUBIS Contains text with dynamic ruby code Uses tags to mark dynamic code ERB Tags Code wrapped in <% %> or <% -%> is a statement that is evaluated. Code wrapped in <%= %> is code that is evaluated and the result is placed into the file. Harcoded strings dont have to be wrapped in erb tags if they are constant, but Ruby code must be wrapped in erb tags if you want the result of that code to go into your file. Templatize MOTD Generate motd template for base cookbook . chef generate template cookbooks/base motd Add the following content to the template file motd.erb . Path: cookbooks/base/templates/default/motd.erb This server is a property of <%= node['org']['name'] %> SYSTEM INFO: HOSTNAME : <%= node['hostname'] %> IP ADDRESS : <%= node['ipaddress'] %> MEMORY : <%= node['memory']['total'] %> Now add organization name as a user defined attribute in attribute file Path: cookbooks/base/attributes/default.rb default['org']['name'] = \"XYZ Inc.\" Complete attribute default.rb of base cookbook is as follows case node['platform_family'] when 'rhel' default['ntp']['service'] = 'ntpd' else default['ntp']['service'] = 'ntp' end default['org']['name'] = \"XYZ Inc.\" Now add template resource to the cookbooks/base/recipes/default.rb recipe file. template '/etc/motd' do source 'motd.erb' owner 'root' group 'root' mode 0644 end Apply using kitchen converge . Attributes Precedence Declaring attributes in various places takes precedence one over another. Let us take an example of declaring port as follows Now let us define organization name in recipe file, before calling attribute in any resource of a recipe. Path: cookbooks/base/recipes/default.rb node.default['org']['name'] = \"School of Devops\" Complete recipe default.rb of base cookbook is as follows user 'deploy' do uid 5001 home '/home/deploy' action :create password '$1$Ze1eJK3R$j5I0NRP5WxbZAaeXcfYW7/' end user 'dojo' do action :remove end package 'ntp' do action :install end package ['tree', 'unzip', 'wget'] do action :install end package 'git' service node['ntp']['service'] do action [ :start, :enable ] end node.default['org']['name'] = \"School of Devops Inc\" template '/etc/motd' do source 'motd.erb' owner 'root' group 'root' mode 0644 end Now apply using kitchen converge Templatizing Tomcat Cookbook (LAB Exercise) Generate a tomcat.conf.erb template for tomcat cookbook. chef generate template cookbooks/tomcat tomcat.conf Generate a default.rb attribute for tomcat cookbook. chef generate attribute cookbooks/tomcat default Add the following content to attribute file. Path: /workspace/myapp/cookbooks/tomcat/attributes/default.rb default['tomcat']['user'] = 'tomcat' default['tomcat']['group'] = 'tomcat' default['tomcat']['config'] = '/etc/tomcat/tomcat.conf' default['tomcat']['packages'] = [ 'tomcat', 'tomcat-webapps' ] default['tomcat']['service'] = 'tomcat' default['tomcat']['user'] = 'tomcat' default['tomcat']['group'] = 'tomcat' default['tomcat']['java_home'] = '/usr/lib/jvm/jre' default['tomcat']['catalina_home'] = '/usr/share/tomcat' default['tomcat']['java_opts'] = '-Xms32m -Xmx64m -XX:MaxPermSize=64M \\ -Djava.security.egd=file:/dev/./urandom' Add the below content to tomcat.conf.erb template. Path: /workspace/myapp/cookbooks/tomcat/templates TOMCAT_CFG_LOADED=\"1\" JAVA_HOME=\"<%= node['tomcat']['java_home'] %>\" JAVA_OPTS=\"<%= node['tomcat']['java_opts'] %>\" CATALINA_BASE=\"/usr/share/tomcat\" CATALINA_HOME=\"<%= node['tomcat']['catalina_home'] %>\" JASPER_HOME=\"/usr/share/tomcat\" CATALINA_TMPDIR=\"/var/cache/tomcat/temp\" TOMCAT_USER=\"<%= node['tomcat']['user'] %>\" SECURITY_MANAGER=\"false\" SHUTDOWN_WAIT=\"30\" SHUTDOWN_VERBOSE=\"false\" CATALINA_PID=\"/var/run/tomcat.pid\" Now update tomcat::config recipe as mentioned below Path: /workspace/myapp/cookbooks/tomcat/recipes/config.rb template node['tomcat']['config'] do source 'tomcat.conf.erb' owner node['tomcat']['user'] group node['tomcat']['group'] mode '0644' action :create notifies :restart, \"service[#{node['tomcat']['service']}]\", :delayed end Apply using kitchen converge Now change the values of JAVA_OPTS in attribute file and then apply again for verifying the changes using template and attribute. Also verify using kitchen login and run ps auwwx command.","title":"Data Driven Cookbooks"},{"location":"07_data_driven_cookbooks_attr_templates/#data-driven-cookbooks","text":"","title":"Data Driven Cookbooks"},{"location":"07_data_driven_cookbooks_attr_templates/#code-vs-data","text":"once the data is taken out of the code then cookbook become generic. Generic cookbook can be used with any OS and environments. Reusability helps in reducing tonnes and tonnes of time.","title":"Code vs Data"},{"location":"07_data_driven_cookbooks_attr_templates/#node-object","text":"It is the representation of each node on chef server in JSON format. If we run a chef-client it generates a node object in chef server in case of nodes or in workstation ( /nodes/*.json ) in case of running locally in workstation.","title":"Node Object"},{"location":"07_data_driven_cookbooks_attr_templates/#attributes","text":"It is used to specify a detail about node. - Attributes are used by the chef-client to understand; - The current state of the node - What the state of the node was at the end of the previous chef-client run - What the state of the node should be at the end of the current chef-client run - Attributes are taken in precedence, according to the place where we specify them, as follows;","title":"Attributes"},{"location":"07_data_driven_cookbooks_attr_templates/#system-defined-attributes","text":"","title":"System Defined Attributes"},{"location":"07_data_driven_cookbooks_attr_templates/#ohai","text":"It installs along with chef-client . It helps in getting all the information about nodes Finding information on node with ohai ohai ohai ipaddress ohai hostname ohai memory ohai memory/total ohai cpu/model_name Referring attributes node['ipaddress'] node['hostname'] node['memory']['total'] node['cpu']['model_name']","title":"OHAI"},{"location":"07_data_driven_cookbooks_attr_templates/#user-defined-attributes","text":"User defined attributes are located in four places as follows Attributes file Recipes Roles Environments","title":"User Defined Attributes"},{"location":"07_data_driven_cookbooks_attr_templates/#attribute-file","text":"How the attribute file looks like? Precedence is defined Attribute and its value is defined as per the above format. Now we can access these attributes in recipe or template as shown below. Example template node['tomcat']['config'] do source 'tomcat.conf.erb' owner node['tomcat']['user'] group node['tomcat']['group'] mode '0644' action :create notifies :restart, \"service[#{node['tomcat']['service']}]\", :delayed end","title":"Attribute File"},{"location":"07_data_driven_cookbooks_attr_templates/#parameterizing-tomcat-configurations","text":"Now let us start creating attribute file Use chef generate to create a file in tomcat cookbook chef generate attribute cookbooks/tomcat default It will create a file as follows cookbooks/tomcat/attributes/default.rb Now we add the attributes and its value in default.rb Path: cookbooks/tomcat/attributes/default.rb default['tomcat']['user'] = 'tomcat' default['tomcat']['group'] = 'tomcat' default['tomcat']['config'] = '/etc/tomcat/tomcat.conf' default['tomcat']['packages'] = [ 'tomcat', 'tomcat-webapps' ] default['tomcat']['service'] = 'tomcat' Now call these attributes in the following recipes tomcat::config will be changed as follows cookbook_file node['tomcat']['config'] do source 'tomcat.conf' owner node['tomcat']['user'] group node['tomcat']['group'] mode '0644' action :create notifies :restart, \"service[#{node['tomcat']['service']}]\", :delayed end tomcat::install will be changed as follows package node['tomcat']['packages'] tomcat::service will be changed as follows service node['tomcat']['service'] do action [ :start, :enable] end Now apply it using kitchen converge and then verify using kitchen verify .","title":"Parameterizing Tomcat Configurations"},{"location":"07_data_driven_cookbooks_attr_templates/#platform-specific-cookbooks","text":"Let us convert our first created base.rb recipe into a cookbook. Create a cookbook using chef generate chef generate cookbook cookbooks/base Now move the base.rb to default.rb of base cookbook. mv /workspace/chapter3/base.rb cookbooks/base/recipes/default.rb Add base::default recipe to the run_list knife node run_list add app1 \"recipe[base]\" Apply on node1 ssh devops@node1 sudo chef-client It fails because the service name for rhel/centos is ntpd and not ntp as like debian. To overcome this we use attribute for platform specific. We use system defined attribute platform_family to do this. Example for ohai platform_family is root@ws:/workspace/myapp# ohai platform_family [ \"debian\" ] root@ws:/workspace/myapp# kitchen login Last login: Thu May 4 05:50:20 2017 from 172.17.0.1 [kitchen@9af3a004e202 ~]$ ohai platform_family [2017-05-04T05:58:19+00:00] INFO: The plugin path /etc/chef/ohai/plugins does not exist. Skipping... [ \"rhel\" ] [kitchen@9af3a004e202 ~]$ logout Connection to localhost closed. root@ws:/workspace/myapp# Now let us create a create a default attribute file for base cookbook using chef generate chef generate attribute cookbooks/base default Now add the following content to attribute file Path: cookbooks/base/attributes/default.rb case node['platform_family'] when 'rhel' default['ntp']['service'] = 'ntpd' else default['ntp']['service'] = 'ntp' end Call the attributes in cookbooks/base/recipes/default.rb recipe service node['ntp']['service'] do action [ :start, :enable ] end Now apply again using kitchen ssh devop@node1 sudo chef-client It is successful now and service is started based on platform. Nano Project - Add some tests for recipes in base cookbook for different platform.","title":"Platform Specific cookbooks"},{"location":"07_data_driven_cookbooks_attr_templates/#templates","text":"A cookbook template is an Embedded Ruby (ERB) template that is used to dynamically generate static text files. Templates are great way to manage configuration files for different environment. ERB or ERUBIS Contains text with dynamic ruby code Uses tags to mark dynamic code ERB Tags Code wrapped in <% %> or <% -%> is a statement that is evaluated. Code wrapped in <%= %> is code that is evaluated and the result is placed into the file. Harcoded strings dont have to be wrapped in erb tags if they are constant, but Ruby code must be wrapped in erb tags if you want the result of that code to go into your file.","title":"Templates"},{"location":"07_data_driven_cookbooks_attr_templates/#templatize-motd","text":"Generate motd template for base cookbook . chef generate template cookbooks/base motd Add the following content to the template file motd.erb . Path: cookbooks/base/templates/default/motd.erb This server is a property of <%= node['org']['name'] %> SYSTEM INFO: HOSTNAME : <%= node['hostname'] %> IP ADDRESS : <%= node['ipaddress'] %> MEMORY : <%= node['memory']['total'] %> Now add organization name as a user defined attribute in attribute file Path: cookbooks/base/attributes/default.rb default['org']['name'] = \"XYZ Inc.\" Complete attribute default.rb of base cookbook is as follows case node['platform_family'] when 'rhel' default['ntp']['service'] = 'ntpd' else default['ntp']['service'] = 'ntp' end default['org']['name'] = \"XYZ Inc.\" Now add template resource to the cookbooks/base/recipes/default.rb recipe file. template '/etc/motd' do source 'motd.erb' owner 'root' group 'root' mode 0644 end Apply using kitchen converge .","title":"Templatize MOTD"},{"location":"07_data_driven_cookbooks_attr_templates/#attributes-precedence","text":"Declaring attributes in various places takes precedence one over another. Let us take an example of declaring port as follows Now let us define organization name in recipe file, before calling attribute in any resource of a recipe. Path: cookbooks/base/recipes/default.rb node.default['org']['name'] = \"School of Devops\" Complete recipe default.rb of base cookbook is as follows user 'deploy' do uid 5001 home '/home/deploy' action :create password '$1$Ze1eJK3R$j5I0NRP5WxbZAaeXcfYW7/' end user 'dojo' do action :remove end package 'ntp' do action :install end package ['tree', 'unzip', 'wget'] do action :install end package 'git' service node['ntp']['service'] do action [ :start, :enable ] end node.default['org']['name'] = \"School of Devops Inc\" template '/etc/motd' do source 'motd.erb' owner 'root' group 'root' mode 0644 end Now apply using kitchen converge","title":"Attributes Precedence"},{"location":"07_data_driven_cookbooks_attr_templates/#templatizing-tomcat-cookbook-lab-exercise","text":"Generate a tomcat.conf.erb template for tomcat cookbook. chef generate template cookbooks/tomcat tomcat.conf Generate a default.rb attribute for tomcat cookbook. chef generate attribute cookbooks/tomcat default Add the following content to attribute file. Path: /workspace/myapp/cookbooks/tomcat/attributes/default.rb default['tomcat']['user'] = 'tomcat' default['tomcat']['group'] = 'tomcat' default['tomcat']['config'] = '/etc/tomcat/tomcat.conf' default['tomcat']['packages'] = [ 'tomcat', 'tomcat-webapps' ] default['tomcat']['service'] = 'tomcat' default['tomcat']['user'] = 'tomcat' default['tomcat']['group'] = 'tomcat' default['tomcat']['java_home'] = '/usr/lib/jvm/jre' default['tomcat']['catalina_home'] = '/usr/share/tomcat' default['tomcat']['java_opts'] = '-Xms32m -Xmx64m -XX:MaxPermSize=64M \\ -Djava.security.egd=file:/dev/./urandom' Add the below content to tomcat.conf.erb template. Path: /workspace/myapp/cookbooks/tomcat/templates TOMCAT_CFG_LOADED=\"1\" JAVA_HOME=\"<%= node['tomcat']['java_home'] %>\" JAVA_OPTS=\"<%= node['tomcat']['java_opts'] %>\" CATALINA_BASE=\"/usr/share/tomcat\" CATALINA_HOME=\"<%= node['tomcat']['catalina_home'] %>\" JASPER_HOME=\"/usr/share/tomcat\" CATALINA_TMPDIR=\"/var/cache/tomcat/temp\" TOMCAT_USER=\"<%= node['tomcat']['user'] %>\" SECURITY_MANAGER=\"false\" SHUTDOWN_WAIT=\"30\" SHUTDOWN_VERBOSE=\"false\" CATALINA_PID=\"/var/run/tomcat.pid\" Now update tomcat::config recipe as mentioned below Path: /workspace/myapp/cookbooks/tomcat/recipes/config.rb template node['tomcat']['config'] do source 'tomcat.conf.erb' owner node['tomcat']['user'] group node['tomcat']['group'] mode '0644' action :create notifies :restart, \"service[#{node['tomcat']['service']}]\", :delayed end Apply using kitchen converge Now change the values of JAVA_OPTS in attribute file and then apply again for verifying the changes using template and attribute. Also verify using kitchen login and run ps auwwx command.","title":"Templatizing Tomcat Cookbook (LAB Exercise)"},{"location":"08_customizing_community_cookbooks/","text":"Customizing Community Cookbooks Customizing Strategy Fork - Directly use the community cookbook by forking the upstream cookbook. Wrapper - Create a wrapper cookbook which calls the community cookbook and customize it, by creating a dependency. Creating myhaproxy cookbook Generate a cookbook called myhaproxy inside sysfoo . cd /workspace/chapter8/sysfoo/ chef generate cookbook cookbooks/myhaproxy Add dependency in myhaproxy/metadata.rb depends 'haproxy', '= 1.6.7' Now add the wrapper content to include and modify haproxy cookbook by adding the following in myhaproxy/recipes/default.rb node.default['haproxy']['members'] = [{ \"hostname\" => \"node1\", \"ipaddress\" => \"node1\", \"port\" => 8080, \"ssl_port\" => 8080 }, { \"hostname\" => \"node2\", \"ipaddress\" => \"node2\", \"port\" => 8080, \"ssl_port\" => 8080 }] node.default['haproxy']['incoming_port'] = 8080 include_recipe 'haproxy::default' Resolve Dependency and Bootstrapping Use berkshelf to resolve dependency of myhaproxy cookbook. Upload the cookbook to server. Now bootstrap node4 by naming it as lb and adding the following run_list base chef-client myhaproxy Verifying Load Balancer After bootstrapping visit http://ip:8084 to check the load Balancer. It is 8084 because the host port 8080 is mapped to 8084.","title":"Customizing Community Cookbooks"},{"location":"08_customizing_community_cookbooks/#customizing-community-cookbooks","text":"","title":"Customizing Community Cookbooks"},{"location":"08_customizing_community_cookbooks/#customizing-strategy","text":"Fork - Directly use the community cookbook by forking the upstream cookbook. Wrapper - Create a wrapper cookbook which calls the community cookbook and customize it, by creating a dependency.","title":"Customizing Strategy"},{"location":"08_customizing_community_cookbooks/#creating-myhaproxy-cookbook","text":"Generate a cookbook called myhaproxy inside sysfoo . cd /workspace/chapter8/sysfoo/ chef generate cookbook cookbooks/myhaproxy Add dependency in myhaproxy/metadata.rb depends 'haproxy', '= 1.6.7' Now add the wrapper content to include and modify haproxy cookbook by adding the following in myhaproxy/recipes/default.rb node.default['haproxy']['members'] = [{ \"hostname\" => \"node1\", \"ipaddress\" => \"node1\", \"port\" => 8080, \"ssl_port\" => 8080 }, { \"hostname\" => \"node2\", \"ipaddress\" => \"node2\", \"port\" => 8080, \"ssl_port\" => 8080 }] node.default['haproxy']['incoming_port'] = 8080 include_recipe 'haproxy::default'","title":"Creating myhaproxy cookbook"},{"location":"08_customizing_community_cookbooks/#resolve-dependency-and-bootstrapping","text":"Use berkshelf to resolve dependency of myhaproxy cookbook. Upload the cookbook to server. Now bootstrap node4 by naming it as lb and adding the following run_list base chef-client myhaproxy","title":"Resolve Dependency and Bootstrapping"},{"location":"08_customizing_community_cookbooks/#verifying-load-balancer","text":"After bootstrapping visit http://ip:8084 to check the load Balancer. It is 8084 because the host port 8080 is mapped to 8084.","title":"Verifying Load Balancer"},{"location":"09_deployment/","text":"Nano Project: Deploy Sysfoo on Tomcat So far you have learnt to write cookbooks, recipes and how to create data driven cookbooks. Now that you have setup tomcat, you have been tasked to write code to deploy a java web application to tomcat server. This application can be pulled from the CI server e.g. Jenkins, CircleCI etc. And the deployment should be automated. Steps : Create a GitHub account Clone sample java webapp repo from https://github.com/schoolofdevops/sample-webapp Create a CircleCI Account https://circleci.com and integrate with your github sample-webapp project, setup the build Write a deploy recipe with chef, add it to run list and test deploy. Deploy Recipe Specs: Create a sysfoo::deploy recipe with the following specifications, * Your recipe should download the artifact (warfile) from circle CI (e.g https://5-94848332-gh.circle-artifacts.com/0/tmp/circle-artifacts.uqT2VIZ/sysfoo.war) * The above URL should be parameterized. Updating the URL using an attribute should deploy the new version. * The resource which downloads the artifact should be idempotent. It should not download the same file again if chef-client is run, unless its a new version of the artifact. * The downloaded artifact should be copied it to the webapps directory of tomcat as app.war. In this example, it would be /usr/share/tomcat/webapps/sysfoo.war * The previous version of the application, if available, should be deleted (path: /usr/share/tomcat/webapps/sysfoo) * Tomcat needs to be restarted whenever a new version of artifact s deployed.","title":"Deploying Sysfoo App"},{"location":"09_deployment/#nano-project-deploy-sysfoo-on-tomcat","text":"So far you have learnt to write cookbooks, recipes and how to create data driven cookbooks. Now that you have setup tomcat, you have been tasked to write code to deploy a java web application to tomcat server. This application can be pulled from the CI server e.g. Jenkins, CircleCI etc. And the deployment should be automated.","title":"Nano Project: Deploy Sysfoo on Tomcat"},{"location":"09_deployment/#steps","text":"Create a GitHub account Clone sample java webapp repo from https://github.com/schoolofdevops/sample-webapp Create a CircleCI Account https://circleci.com and integrate with your github sample-webapp project, setup the build Write a deploy recipe with chef, add it to run list and test deploy.","title":"Steps :"},{"location":"09_deployment/#deploy-recipe-specs","text":"Create a sysfoo::deploy recipe with the following specifications, * Your recipe should download the artifact (warfile) from circle CI (e.g https://5-94848332-gh.circle-artifacts.com/0/tmp/circle-artifacts.uqT2VIZ/sysfoo.war) * The above URL should be parameterized. Updating the URL using an attribute should deploy the new version. * The resource which downloads the artifact should be idempotent. It should not download the same file again if chef-client is run, unless its a new version of the artifact. * The downloaded artifact should be copied it to the webapps directory of tomcat as app.war. In this example, it would be /usr/share/tomcat/webapps/sysfoo.war * The previous version of the application, if available, should be deleted (path: /usr/share/tomcat/webapps/sysfoo) * Tomcat needs to be restarted whenever a new version of artifact s deployed.","title":"Deploy Recipe Specs:"},{"location":"10_roles/","text":"Roles To create a roles in chef DSL we need to create a folder named roles inside the repo directory (sysfoo/roles) . A sample role file consist of the following, Name Description Run_list Attributes A sample role file is as follows roles/sample.rb name \"starter\" description \"An example Chef role\" run_list \"recipe[starter]\" override_attributes({ \"starter_name\" => \"starter\", }) Creating Roles for sysfoo Now create a roles for application and load_balancer. sysfoo/roles/app.rb sysfoo/roles/lb.rb Add the following content to app.rb name \"app\" description \"Tomcat Application Server\" run_list \"recipe[base]\", \"recipe[tomcat]\", \"recipe[chef-client]\", \"recipe[sysfoo::deploy]\" override_attributes({ \"chef_client\" => { \"interval\" => 120, \"splay\" => 30 } }) Add the following content to lb.rb name \"lb\" description \"Load Balancer\" run_list \"recipe[base]\", \"recipe[myhaproxy]\", \"recipe[chef-client]\" override_attributes({ \"chef_client\" => { \"interval\" => 60, \"splay\" => 20 } }) Uploading Roles to Chef Server From the sysfoo directory using knife command upload the roles from file app.rb and lb.rb knife role from file app.rb lb.rb Applying Roles to Run_list Now replace the existing run_list of nodes with roles. Add run_list to node1 knife node run_list set app1 \"role[app]\" Add run_list to node2 knife node run_list set app2 \"role[app]\" Add run_list to node4 knife node run_list set lb \"role[lb]\" Run chef-client on all nodes Now we need to run chef-client on all nodes. We can do this by passing a sudo chef-client command to all nodes using knife as follows knife ssh \"*:*\" -x devops -a ipaddress \"sudo chef-client\" Verify the changes using ps aux | grep chef-client on all nodes to find the time interval. knife ssh \"*:*\" -x devops -a ipaddress \"ps aux | grep chef-client\"","title":"Roles"},{"location":"10_roles/#roles","text":"To create a roles in chef DSL we need to create a folder named roles inside the repo directory (sysfoo/roles) . A sample role file consist of the following, Name Description Run_list Attributes A sample role file is as follows roles/sample.rb name \"starter\" description \"An example Chef role\" run_list \"recipe[starter]\" override_attributes({ \"starter_name\" => \"starter\", })","title":"Roles"},{"location":"10_roles/#creating-roles-for-sysfoo","text":"Now create a roles for application and load_balancer. sysfoo/roles/app.rb sysfoo/roles/lb.rb Add the following content to app.rb name \"app\" description \"Tomcat Application Server\" run_list \"recipe[base]\", \"recipe[tomcat]\", \"recipe[chef-client]\", \"recipe[sysfoo::deploy]\" override_attributes({ \"chef_client\" => { \"interval\" => 120, \"splay\" => 30 } }) Add the following content to lb.rb name \"lb\" description \"Load Balancer\" run_list \"recipe[base]\", \"recipe[myhaproxy]\", \"recipe[chef-client]\" override_attributes({ \"chef_client\" => { \"interval\" => 60, \"splay\" => 20 } })","title":"Creating Roles for sysfoo"},{"location":"10_roles/#uploading-roles-to-chef-server","text":"From the sysfoo directory using knife command upload the roles from file app.rb and lb.rb knife role from file app.rb lb.rb","title":"Uploading Roles to Chef Server"},{"location":"10_roles/#applying-roles-to-run_list","text":"Now replace the existing run_list of nodes with roles. Add run_list to node1 knife node run_list set app1 \"role[app]\" Add run_list to node2 knife node run_list set app2 \"role[app]\" Add run_list to node4 knife node run_list set lb \"role[lb]\"","title":"Applying Roles to Run_list"},{"location":"10_roles/#run-chef-client-on-all-nodes","text":"Now we need to run chef-client on all nodes. We can do this by passing a sudo chef-client command to all nodes using knife as follows knife ssh \"*:*\" -x devops -a ipaddress \"sudo chef-client\" Verify the changes using ps aux | grep chef-client on all nodes to find the time interval. knife ssh \"*:*\" -x devops -a ipaddress \"ps aux | grep chef-client\"","title":"Run chef-client on all nodes"},{"location":"11_search/","text":"Search Search is used to run a query on chef-server. To search for nodes, roles, environment and data bags. Search patterns include exact, wildcards and range. Search can be included within recipe or using knife CLI. Replacing myhaproxy recipe Instead of adding the additional web servers manually to the list of haproxy, we can use search inside recipe to perform that. Now we can change the default recipe as follows Path: sysfoo/cookbooks/myhaproxy/recipes/default.rb all_web_nodes = search(\"node\", \"role:app\") members = [ ] all_web_nodes.each do | web_node | member = { 'hostname' => web_node['hostname'], 'ipaddress' => web_node['ipaddress'], 'port' => 8080, 'ssl_port' => 8080 } members.push(member) end node.default['haproxy']['members'] = members node.default['haproxy']['incoming_port'] = 8080 include_recipe 'haproxy::default' Now before uploading this to chef server we will change the version of cookbook by adding the version in metadata. Change the version in sysfoo/cookbooks/myhaproxy/metadata.rb from 0.1.0 to 0.2.0 . Upload the myhaproxy cookbook. Verifying Search Functionality Now bootstrap node3 as web server using the role app. Before bootstrap watch the haproxy.cfg file in node4(Load Balancer) , which will be getting updated for every 60 seconds defined by chef-client process. watch -n 1 tail /etc/haproxy/haproxy.cfg Now bootstrap node3 from workstation, knife bootstrap node3 -x devops --sudo -N \"app3\" -r \"role[app]\" After a minute we can see the entry of new web-server node3 added to the load balancer configuration file.","title":"Search"},{"location":"11_search/#search","text":"Search is used to run a query on chef-server. To search for nodes, roles, environment and data bags. Search patterns include exact, wildcards and range. Search can be included within recipe or using knife CLI.","title":"Search"},{"location":"11_search/#replacing-myhaproxy-recipe","text":"Instead of adding the additional web servers manually to the list of haproxy, we can use search inside recipe to perform that. Now we can change the default recipe as follows Path: sysfoo/cookbooks/myhaproxy/recipes/default.rb all_web_nodes = search(\"node\", \"role:app\") members = [ ] all_web_nodes.each do | web_node | member = { 'hostname' => web_node['hostname'], 'ipaddress' => web_node['ipaddress'], 'port' => 8080, 'ssl_port' => 8080 } members.push(member) end node.default['haproxy']['members'] = members node.default['haproxy']['incoming_port'] = 8080 include_recipe 'haproxy::default' Now before uploading this to chef server we will change the version of cookbook by adding the version in metadata. Change the version in sysfoo/cookbooks/myhaproxy/metadata.rb from 0.1.0 to 0.2.0 . Upload the myhaproxy cookbook.","title":"Replacing myhaproxy recipe"},{"location":"11_search/#verifying-search-functionality","text":"Now bootstrap node3 as web server using the role app. Before bootstrap watch the haproxy.cfg file in node4(Load Balancer) , which will be getting updated for every 60 seconds defined by chef-client process. watch -n 1 tail /etc/haproxy/haproxy.cfg Now bootstrap node3 from workstation, knife bootstrap node3 -x devops --sudo -N \"app3\" -r \"role[app]\" After a minute we can see the entry of new web-server node3 added to the load balancer configuration file.","title":"Verifying Search Functionality"},{"location":"12_environments/","text":"Chapter 12: Creating Configuration Profiles with Environments In this lab we are going to use chef's environment primitive to, * Create different configuration profiles. Setup environment specific configurations. * Set cookbook versioning constraints. Define cookbook versions to be used in each environment. This way you could limit your experimentation with your own dev env without affecting rest of the environments. * Provide isolation in combination with search. Making search more specific with environments In the previous module, we learnt about search, and even incorporated it to auto discover app servers from load balancer. However with the current configurations, the search results will return list of all app servers, irrespective of the environment. We need to make this search specific to the node's environment. Lets update myhaproxy recipe accordingly Path: cookbooks/myhaproxy/recipes/default.rb Update the line which uses search to, all_web_nodes = search(\"node\", \"role:app AND chef_environment:#{node.chef_environment}\") Also update the version in the metadata. Path: cookbooks/myhaproxy/metadata.rb version '0.3.0' Upload the cookbook knife cookbook upload myhaproxy Creating a prod environment Create a environment file Path: sysfoo/environments/prod.rb name \"prod\" description \"Production Environment\" cookbook \"myhaproxy\", \"= 0.3.0\" default_attributes({ \"tomcat\" => { \"deploy\" => { \"url\" => 'https://11-94848332-gh.circle-artifacts.com/0/tmp/circle-artifacts.6gxaMPh/sysfoo.war'} } }) Uploading and exploring environment knife environment from file prod.rb knife environment show prod Bringing nodes into the environment From node4 keep watching the haproxy.cfg watch -n 1 tail /etc/haproxy/haproxy.cfg Lets bring in two nodes into prod env knife node environment set app1 prod knife node environment set app2 prod Keep watching the haproxy config. It should take the two nodes off as the load balancer still belongs to _default env . Lets bring load balancer into the prod env knife node environment set lb prod See as the LB limits itself to serve only to the app servers in its own environment. You should also see two differnt versions of the applications running in the two environments vz production and _default .","title":"Environments"},{"location":"12_environments/#chapter-12-creating-configuration-profiles-with-environments","text":"In this lab we are going to use chef's environment primitive to, * Create different configuration profiles. Setup environment specific configurations. * Set cookbook versioning constraints. Define cookbook versions to be used in each environment. This way you could limit your experimentation with your own dev env without affecting rest of the environments. * Provide isolation in combination with search.","title":"Chapter 12: Creating Configuration Profiles with Environments"},{"location":"12_environments/#making-search-more-specific-with-environments","text":"In the previous module, we learnt about search, and even incorporated it to auto discover app servers from load balancer. However with the current configurations, the search results will return list of all app servers, irrespective of the environment. We need to make this search specific to the node's environment. Lets update myhaproxy recipe accordingly Path: cookbooks/myhaproxy/recipes/default.rb Update the line which uses search to, all_web_nodes = search(\"node\", \"role:app AND chef_environment:#{node.chef_environment}\") Also update the version in the metadata. Path: cookbooks/myhaproxy/metadata.rb version '0.3.0' Upload the cookbook knife cookbook upload myhaproxy","title":"Making search more specific with environments"},{"location":"12_environments/#creating-a-prod-environment","text":"Create a environment file Path: sysfoo/environments/prod.rb name \"prod\" description \"Production Environment\" cookbook \"myhaproxy\", \"= 0.3.0\" default_attributes({ \"tomcat\" => { \"deploy\" => { \"url\" => 'https://11-94848332-gh.circle-artifacts.com/0/tmp/circle-artifacts.6gxaMPh/sysfoo.war'} } })","title":"Creating a prod environment"},{"location":"12_environments/#uploading-and-exploring-environment","text":"knife environment from file prod.rb knife environment show prod","title":"Uploading and exploring environment"},{"location":"12_environments/#bringing-nodes-into-the-environment","text":"From node4 keep watching the haproxy.cfg watch -n 1 tail /etc/haproxy/haproxy.cfg Lets bring in two nodes into prod env knife node environment set app1 prod knife node environment set app2 prod Keep watching the haproxy config. It should take the two nodes off as the load balancer still belongs to _default env . Lets bring load balancer into the prod env knife node environment set lb prod See as the LB limits itself to serve only to the app servers in its own environment. You should also see two differnt versions of the applications running in the two environments vz production and _default .","title":"Bringing nodes into the environment"},{"location":"13-applying-with-solo/","text":"Applying code with chef-solo Even though a typical installation of chef includes a chef server and nodes running chef-client and working in a pull model, there are times your organization may not have a server and uses chef-solo instead. In a severless model, there are three ways you could apply the code with following utilities * chef-apply * chef-solo * chef-client --local-mode | -z Even though, officially Chef recommends using chef-client with local mode as it creates a in memory server, file: solo.rb cookbook_path \"/home/devops/sysfoo/cookbooks\" role_path \"/home/devops/sysfoo/cookbooks/roles\" environment_path \"/home/devops/sysfoo/cookbooks/environments\" environment \"prod\" file: node.json { \"run_list\" : \"role[app]\"} Steps Create solo.rb Create node.json Copy over the following cookbooks roles environments Generate dependencies and vendor those with the following command berks vendor /path","title":"Chef Solo"},{"location":"13-applying-with-solo/#applying-code-with-chef-solo","text":"Even though a typical installation of chef includes a chef server and nodes running chef-client and working in a pull model, there are times your organization may not have a server and uses chef-solo instead. In a severless model, there are three ways you could apply the code with following utilities * chef-apply * chef-solo * chef-client --local-mode | -z Even though, officially Chef recommends using chef-client with local mode as it creates a in memory server, file: solo.rb cookbook_path \"/home/devops/sysfoo/cookbooks\" role_path \"/home/devops/sysfoo/cookbooks/roles\" environment_path \"/home/devops/sysfoo/cookbooks/environments\" environment \"prod\" file: node.json { \"run_list\" : \"role[app]\"}","title":"Applying code with chef-solo"},{"location":"13-applying-with-solo/#steps","text":"Create solo.rb Create node.json Copy over the following cookbooks roles environments Generate dependencies and vendor those with the following command berks vendor /path","title":"Steps"},{"location":"markdown_cheatsheet/","text":"Markdown Cheatsheet {pagebreak} Part Section Sub Section Sub Sub Section Sub Sub Sub Section This is the first para This is the 2nd para separated by a line This is the 3rd para separated by 2 spaces at the end of line before c> This is a centered text italic bold bold-italic _underlined _ Numbered list item 1 Numbered list item 2 Numbered list item 3 with * para between list item 4 indents, blank like after prev item, num seq continues Numbered list item 3 Bullet list item 1 Bullet list item 2 Sub Item 2.1 Sub Sub item 2.1.1 Bullet list item 3 ![caption](images/path_to_image) Header : description of the header This is a Block Quote Block Quote gets indented block quote inside a block quote Text Blocks Asides A> ## This is an aside A> A> This gets printed in a block Warnings W> ## This is a Warning W> W> Always wear the seat belt Tips T> ## This is a tip T> T> Bet for number 5 on that table Errors E> ## This prints an error E> E> Oops ! You just barged into ladies toilet Information I> ## This is to print info I> I> For your eyes only Questions Q> ## This prints questions Q> Q> What came first, chicken or the egg? Discussions D> ## This is for Discussions D> D> Lets talk about Life of Pie Exercises X> ## This is for exercises X> X> 10 mins on treadmill X> followed by two sets of pushups Writing Code Method 1 : 4 space indentation echo \"this starts with 4 indents\" ls -l cat /etc/issue uptime Method 2: 8 tildes echo \"this has 8 tildes on the top and bottom\" echo \"8 tildes is a best practice, but any no. will do \" uptime ls -l cat /etc/issue Method 3 : include code from file <<(code/sample_code.sh) << sample_code_with_title Method 4 : lp-code style {title=\"Listing \", lang=html, linenos=off} echo \"this is autocompleted by leanpub plugin for atom\" uptime df -h ls -l Method 5: back ticks `` echo \"this is a short code snippet\" Footnotes This is a text para and I am writing a footnote[^tag1] here Later on I add the footnote as [^tag1]: description about the footnote. Should contain blank line before and after Crosslinks This is a cross link to {##Sub Section} Table header1 header2 r1-c1 r1-c2 r2-c1 r2-c2 r3-c1 r3-c2 Header One Header Two Item One Item Two","title":"Markdown Cheatsheet"},{"location":"markdown_cheatsheet/#markdown-cheatsheet","text":"{pagebreak}","title":"Markdown Cheatsheet"},{"location":"markdown_cheatsheet/#part","text":"","title":"Part"},{"location":"markdown_cheatsheet/#section","text":"","title":"Section"},{"location":"markdown_cheatsheet/#sub-section","text":"","title":"Sub Section"},{"location":"markdown_cheatsheet/#sub-sub-section","text":"","title":"Sub Sub Section"},{"location":"markdown_cheatsheet/#sub-sub-sub-section","text":"This is the first para This is the 2nd para separated by a line This is the 3rd para separated by 2 spaces at the end of line before c> This is a centered text italic bold bold-italic _underlined _ Numbered list item 1 Numbered list item 2 Numbered list item 3 with * para between list item 4 indents, blank like after prev item, num seq continues Numbered list item 3 Bullet list item 1 Bullet list item 2 Sub Item 2.1 Sub Sub item 2.1.1 Bullet list item 3 ![caption](images/path_to_image) Header : description of the header This is a Block Quote Block Quote gets indented block quote inside a block quote Text Blocks Asides A> ## This is an aside A> A> This gets printed in a block Warnings W> ## This is a Warning W> W> Always wear the seat belt Tips T> ## This is a tip T> T> Bet for number 5 on that table Errors E> ## This prints an error E> E> Oops ! You just barged into ladies toilet Information I> ## This is to print info I> I> For your eyes only Questions Q> ## This prints questions Q> Q> What came first, chicken or the egg? Discussions D> ## This is for Discussions D> D> Lets talk about Life of Pie Exercises X> ## This is for exercises X> X> 10 mins on treadmill X> followed by two sets of pushups Writing Code Method 1 : 4 space indentation echo \"this starts with 4 indents\" ls -l cat /etc/issue uptime Method 2: 8 tildes echo \"this has 8 tildes on the top and bottom\" echo \"8 tildes is a best practice, but any no. will do \" uptime ls -l cat /etc/issue Method 3 : include code from file <<(code/sample_code.sh) << sample_code_with_title Method 4 : lp-code style {title=\"Listing \", lang=html, linenos=off} echo \"this is autocompleted by leanpub plugin for atom\" uptime df -h ls -l Method 5: back ticks `` echo \"this is a short code snippet\" Footnotes This is a text para and I am writing a footnote[^tag1] here Later on I add the footnote as [^tag1]: description about the footnote. Should contain blank line before and after Crosslinks This is a cross link to {##Sub Section} Table header1 header2 r1-c1 r1-c2 r2-c1 r2-c2 r3-c1 r3-c2 Header One Header Two Item One Item Two","title":"Sub Sub Sub Section"},{"location":"preface/","text":"Preface Learn from zero and end up being a chef master.","title":"Preface"},{"location":"preface/#preface","text":"Learn from zero and end up being a chef master.","title":"Preface"}]}